type AcademiesChildTag implements AcademiesTag {
  subId: ID!
  coordinates: AcademiesTagCoordinates!
  id: ID!
  data: AcademiesTagData!
  kind: AcademiesTagKind!
  children(before: String, after: String, first: Int, last: Int): AcademiesChildTagsConnection!
  canBeDeleted: Boolean!
}

"""A connection to a list of items."""
type AcademiesChildTagsConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [AcademiesChildTagsEdge]
}

"""An edge in a connection."""
type AcademiesChildTagsEdge {
  """The item at the end of the edge."""
  node: AcademiesChildTag!

  """A cursor for use in pagination."""
  cursor: String!
}

type AcademiesRootTag implements AcademiesTag {
  subId: ID!
  id: ID!
  data: AcademiesTagData!
  kind: AcademiesTagKind!
  children(before: String, after: String, first: Int, last: Int): AcademiesChildTagsConnection!
  canBeDeleted: Boolean!
}

"""A connection to a list of items."""
type AcademiesRootTagsConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [AcademiesRootTagsEdge]
}

"""An edge in a connection."""
type AcademiesRootTagsEdge {
  """The item at the end of the edge."""
  node: AcademiesRootTag!

  """A cursor for use in pagination."""
  cursor: String!
}

interface AcademiesTag {
  id: ID!
  data: AcademiesTagData!
  kind: AcademiesTagKind!
  children(before: String, after: String, first: Int, last: Int): AcademiesChildTagsConnection!
  canBeDeleted: Boolean!
}

"""Data only accessible by the admin"""
type AcademiesTagAdminMutationSchema {
  createRootTag(input: CreateRootTagInput!): CreateRootTagPayload
  createAndAppendChildTag(input: CreateAndAppendChildTagInput!): CreateAndAppendChildTagPayload
  editTag(input: editTagInput!): editTagPayload
  deleteTag(input: deleteTagInput!): deleteTagPayload
}

"""Data only accessible by the admin"""
type AcademiesTagAdminSchema {
  RootTags(before: String, after: String, first: Int, last: Int, name: String, isTopic: Boolean, isClickable: Boolean): AcademiesRootTagsConnection!
  SelectTags(before: String, after: String, first: Int, last: Int, isRoot: Boolean, name: String, isTopic: Boolean, isClickable: Boolean): AcademiesTagsConnection!
}

type AcademiesTagCoordinates {
  root: AcademiesRootTag
  parent: AcademiesTag
}

type AcademiesTagData {
  name: String!
  isTopic: Boolean!
  isClickable: Boolean!
}

enum AcademiesTagKind {
  Root
  Child
}

type AcademiesTagQueries {
  AcademiesTags(before: String, after: String, first: Int, last: Int): AcademiesRootTagsConnection!
}

"""A connection to a list of items."""
type AcademiesTagsConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [AcademiesTagsEdge]
}

"""An edge in a connection."""
type AcademiesTagsEdge {
  """The item at the end of the edge."""
  node: AcademiesTag!

  """A cursor for use in pagination."""
  cursor: String!
}

input AcceptInvitationInput {
  token: String!
  clientMutationId: String
}

type AcceptInvitationPayload {
  clientMutationId: String
}

input AcceptInviteWithNewUserInput {
  token: String!
  email: String!
  rawPassword: String!
  firstName: String!
  lastName: String!
  position: String
  adsOptIn: Boolean!
  branch: Branch
  teamSize: TeamSize
  clientMutationId: String
}

type AcceptInviteWithNewUserPayload {
  loginResult: LoginResult!
  clientMutationId: String
}

type Account implements Node {
  """The ID of an object"""
  id: ID!
  name: String!
  groupAssociations: [AccountGroupAssociation!]!
  isDeleted: Boolean!
  registeredAt: ZonedDateTIme!
  extension: AccountExtension!
}

"""Data only accessible by the admin"""
type AccountBaseDataAdminMutationSchema {
  editBusinessBaseData(input: EditBusinessBaseDataAdminInput!): EditBusinessBaseDataAdminPayload
  editPrivateBaseData(input: EditPrivateBaseDataAdminInput!): EditPrivateBaseDataAdminPayload
}

"""Data only accessible by the admin"""
type AccountBaseDataAdminSchema {
  AccountBaseData(before: String, after: String, first: Int, last: Int, filterByAccountId: ID!): baseData!
}

type AccountBaseDataMutations {
  editBusinessBaseData(input: EditBusinessBaseDataInput!): EditBusinessBaseDataPayload
  editPrivateBaseData(input: EditPrivateBaseDataInput!): EditPrivateBaseDataPayload
  setAccountBaseDataCountry(input: SetAccountBaseDataCountryInput!): SetAccountBaseDataCountryPayload
}

type AccountBaseDataQueries {
  AccountBaseData: baseData!
}

"""A connection to a list of items."""
type AccountConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [AccountEdge]
}

type AccountData {
  bic: String
  iban: String!
}

input AccountDataInput {
  bic: String
  iban: String!
}

"""An edge in a connection."""
type AccountEdge {
  """The item at the end of the edge."""
  node: Account!

  """A cursor for use in pagination."""
  cursor: String!
}

interface AccountExtension {
  doNotUse: String!
}

type AccountExtensionImpl implements AccountExtension {
  users(before: String, after: String, first: Int, last: Int): UserInAccountConnection!
  licenses(before: String, after: String, first: Int, last: Int): LicenseConnection!
  baseData: baseData!
  licenseModelKind: Kind
  doNotUse: String!
}

type AccountGroup implements Node {
  """The ID of an object"""
  id: ID!
  name: String!
  permissions: [Permission!]!
  isBuiltIn: Boolean!
}

type AccountGroupAssignmentRule implements AssignmentRule & Node {
  name: String!
  userInAccountGroups: [UserInAccountGroup!]!
  amountEffectedUser: Long!
  active: Boolean!

  """The ID of an object"""
  id: ID!
  licenseGroupingId: ID!
  accountRef: ID!
}

type AccountGroupAssociation {
  group: AccountGroup
}

type AccountGroupProduct implements Product & Node {
  isTaxFree: Boolean!
  netPrice: BigDecimal!
  chGrossPrice: BigDecimal!
  atGrossPrice: BigDecimal!
  deGrossPrice: BigDecimal!
  costUnit: String
  accountGroupId: ID
  id: ID!
  title: String!
  price: Price!
  isHidden: Boolean!
  productType: String!
}

"""A connection to a list of items."""
type AccountGroupsConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [AccountGroupsEdge]
}

"""An edge in a connection."""
type AccountGroupsEdge {
  """The item at the end of the edge."""
  node: AccountGroup!

  """A cursor for use in pagination."""
  cursor: String!
}

interface AccountMember {
  id: ID!
  name: String!
  groups: [UserInAccountGroup!]!
  isManager: Boolean!
  kind: AccountMemberKind!
}

"""A connection to a list of items."""
type AccountMemberConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [AccountMemberEdge]
}

"""An edge in a connection."""
type AccountMemberEdge {
  """The item at the end of the edge."""
  node: AccountMember!

  """A cursor for use in pagination."""
  cursor: String!
}

enum AccountMemberKind {
  UserInAccount
  Invitation
}

type AccountMemberManagementMutations {
  inviteOrAddUsersToUserInAccountGroups(input: InviteOrAddUsersToUserInAccountGroupsInput!): InviteOrAddUsersToUserInAccountGroupsPayload
  createUserInAccountGroupAndAddOrInviteUsersMutation(input: CreateUserInAccountGroupAndAddOrInviteUsersMutationInput!): CreateUserInAccountGroupAndAddOrInviteUsersMutationPayload
  editUserInAccountGroupAndAddOrInviteUsersMutation(input: EditUserInAccountGroupAndAddOrInviteUsersMutationInput!): EditUserInAccountGroupAndAddOrInviteUsersMutationPayload
  deleteUserInAccountGroups(input: DeleteUserInAccountGroupsInput!): DeleteUserInAccountGroupsPayload
  removeUsersFromUserInAccountGroup(input: RemoveUsersFromUserInAccountGroupInput!): RemoveUsersFromUserInAccountGroupPayload
  removeUsersFromAccount(input: RemoveUsersFromAccountInput!): RemoveUsersFromAccountPayload
  deleteInvitation(input: DeleteInvitationInput!): DeleteInvitationPayload
  anonymizeAccountAsOwner(input: AnonymizeAccountAsOwnerInput!): AnonymizeAccountAsOwnerPayload
}

type AccountMemberManagementQueries {
  AccountMembers(filterByNameOrEmail: String, filterByGroupIds: [ID!]!, filterByAccountMemberKind: AccountMemberKind): AccountMembersResult!
  UserInAccountGroupWrappers(before: String, after: String, first: Int, last: Int, filterByName: String, includeOwner: Boolean!, includeUser: Boolean!, doCalcMemberCount: Boolean!): UserInAccountGroupWrappersResult!
  UserInAccountGroupWrapper(id: ID!): UserInAccountGroupWrapper
}

type AccountMembersResult {
  accountMembers(before: String, after: String, first: Int, last: Int): AccountMemberConnection!
  userCount: Long!
  invitationCount: Long!
}

type AccountPermissions {
  accountRef: ID!
  permissions: [Permission!]!
}

input AcknowledgePotentialAnalysisMaxRewardInput {
  clientMutationId: String
}

type AcknowledgePotentialAnalysisMaxRewardPayload {
  clientMutationId: String
}

input AcknowledgePublishingV2Input {
  publishingId: ID!
  clientMutationId: String
}

type AcknowledgePublishingV2Payload {
  publishing: PublishingV2!
  clientMutationId: String
}

input ActivateUserInput {
  token: String!
  clientMutationId: String
}

type ActivateUserPayload {
  clientMutationId: String
}

type ActiveAsyncContentSubmissionDefinition implements AsyncContentSubmissionDefinition & ContentSubmissionDefinition {
  element: AsyncLearnElement
  status: ContentSubmissionStatus!
  contentKind: ContentKind!
}

type ActiveELearningContentSubmissionDefinition implements ELearningContentSubmissionDefinition & ContentSubmissionDefinition {
  currentElementState: ElementState
  canGoToPrevious: Boolean!
  canGoToNext: Boolean!
  progress: ELearningContentSubmissionProgress!
  relativeProgress: ELearningContentSubmissionRelativeProgress!
  status: ContentSubmissionStatus!
  contentKind: ContentKind!
}

type ActiveELearningContentSubmissionProgress implements ELearningContentSubmissionProgress {
  isAtLastElement: Boolean!
  numElements: Int!
  currentElementIndex: Int!
  percentage: Int!
}

input AddAfterDateTimeVisibilityTreeConfigInput {
  dateTime: ZonedDateTIme!
  rootNodeId: ID!
  clientMutationId: String
}

type AddAfterDateTimeVisibilityTreeConfigPayload {
  rootNode: TreeNode!
  clientMutationId: String
}

input AddBlockPermanentlyRestartIfFailedContentConfigInput {
  maximumTries: Int!
  contentNodeId: ID!
  clientMutationId: String
}

type AddBlockPermanentlyRestartIfFailedContentConfigPayload {
  contentNode: TreeNode!
  clientMutationId: String
}

input AddBlockTemporarilyRestartIfFailedContentConfigInput {
  daysToBlock: Int!
  contentNodeId: ID!
  clientMutationId: String
}

type AddBlockTemporarilyRestartIfFailedContentConfigPayload {
  contentNode: TreeNode!
  clientMutationId: String
}

input AddCanAfterStartingTreeStartContentConfigInput {
  contentId: ID!
  clientMutationId: String
}

type AddCanAfterStartingTreeStartContentConfigPayload {
  content: TreeNode!
  clientMutationId: String
}

input AddCanIfUnlockedStartContentConfigInput {
  contentId: ID!
  clientMutationId: String
}

type AddCanIfUnlockedStartContentConfigPayload {
  content: TreeNode!
  clientMutationId: String
}

input AddCanNotRestartIfFailedContentConfigInput {
  contentNodeId: ID!
  clientMutationId: String
}

type AddCanNotRestartIfFailedContentConfigPayload {
  contentNode: TreeNode!
  clientMutationId: String
}

input AddColumnToMatrixElementInput {
  columnTitle: String!
  correctAnswerContent: String!
  matrixElementId: ID!
  clientMutationId: String
}

type AddColumnToMatrixElementPayload {
  eLearningContent: TreeNode!
  matrixElement: MatrixElement!
  clientMutationId: String
}

input AddCrmTreeHeadUpdaterRewardInput {
  contentId: ID!
  clientMutationId: String
}

type AddCrmTreeHeadUpdaterRewardPayload {
  content: TreeNode!
  clientMutationId: String
}

input AddDefaultFileAttachmentInput {
  titleOpt: String
  descriptionOpt: String
  nodeId: ID!
  fileId: ID!
  clientMutationId: String
}

type AddDefaultFileAttachmentPayload {
  node: TreeNode!
  clientMutationId: String
}

input AddDoNotRewardTreeConfigInput {
  rootNodeId: ID!
  clientMutationId: String
}

type AddDoNotRewardTreeConfigPayload {
  rootNode: TreeNode!
  clientMutationId: String
}

input AddEducationalParticipationCertificateRewardInput {
  contentId: ID!
  data: ParticipationCertificateRewardDataInput!
  clientMutationId: String
}

type AddEducationalParticipationCertificateRewardPayload {
  content: TreeNode!
  clientMutationId: String
}

input AddExternalLicenseRewardInput {
  data: ExternalLicenseRewardDataInput!
  contentId: ID!
  clientMutationId: String
}

type AddExternalLicenseRewardPayload {
  content: TreeNode!
  clientMutationId: String
}

input AddHideVisibilityCoachingConfigInput {
  coachingOfferId: ID!
  clientMutationId: String
}

type AddHideVisibilityCoachingConfigPayload {
  coachingOffer: CoachingOffer!
  clientMutationId: String
}

input AddHideVisibilityTreeConfigInput {
  rootNodeId: ID!
  clientMutationId: String
}

type AddHideVisibilityTreeConfigPayload {
  rootNode: TreeNode!
  clientMutationId: String
}

input AddIHKCertificateRewardInput {
  contentId: ID!
  clientMutationId: String
}

type AddIHKCertificateRewardPayload {
  content: TreeNode!
  clientMutationId: String
}

input AddMatchingPlacementInput {
  matchingId: String!
  userId: ID!
  accountId: ID!
  clientMutationId: String
}

type AddMatchingPlacementPayload {
  linkToCoachingOffer: String!
  clientMutationId: String
}

input AddNotAfterDateTimeVisibilityTreeConfigInput {
  dateTime: ZonedDateTIme!
  rootNodeId: ID!
  clientMutationId: String
}

type AddNotAfterDateTimeVisibilityTreeConfigPayload {
  rootNode: TreeNode!
  clientMutationId: String
}

input AddOnlyAdminsVisibilityTreeConfigInput {
  rootNodeId: ID!
  clientMutationId: String
}

type AddOnlyAdminsVisibilityTreeConfigPayload {
  rootNode: TreeNode!
  clientMutationId: String
}

input AddOnlyAZAVAccountVisibilityCoachingConfigInput {
  coachingOfferId: ID!
  clientMutationId: String
}

type AddOnlyAZAVAccountVisibilityCoachingConfigPayload {
  coachingOffer: CoachingOffer!
  clientMutationId: String
}

input AddOnlyAZAVAccountVisibilityTreeConfigInput {
  rootNodeId: ID!
  clientMutationId: String
}

type AddOnlyAZAVAccountVisibilityTreeConfigPayload {
  rootNode: TreeNode!
  clientMutationId: String
}

input AddOnlyBusinessAccountVisibilityCoachingConfigInput {
  coachingOfferId: ID!
  clientMutationId: String
}

type AddOnlyBusinessAccountVisibilityCoachingConfigPayload {
  coachingOffer: CoachingOffer!
  clientMutationId: String
}

input AddOnlyBusinessAccountVisibilityTreeConfigInput {
  rootNodeId: ID!
  clientMutationId: String
}

type AddOnlyBusinessAccountVisibilityTreeConfigPayload {
  rootNode: TreeNode!
  clientMutationId: String
}

input AddOnlyEditorsVisibilityTreeConfigInput {
  rootNodeId: ID!
  clientMutationId: String
}

type AddOnlyEditorsVisibilityTreeConfigPayload {
  rootNode: TreeNode!
  clientMutationId: String
}

input AddOnlyIfTreeStateVisibilityTreeConfigInput {
  rootNodeId: ID!
  clientMutationId: String
}

type AddOnlyIfTreeStateVisibilityTreeConfigPayload {
  rootNode: TreeNode!
  clientMutationId: String
}

input AddOnlyWithLicenseVisibilityCoachingConfigInput {
  coachingOfferId: ID!
  clientMutationId: String
}

type AddOnlyWithLicenseVisibilityCoachingConfigPayload {
  coachingOffer: CoachingOffer!
  clientMutationId: String
}

input AddOrderItemInput {
  text: String!
  orderElementId: ID!
  clientMutationId: String
}

type AddOrderItemPayload {
  orderElement: OrderElement!
  clientMutationId: String
}

input AddParticipantAdminInput {
  availabilityId: ID!
  participantId: ID!
  clientMutationId: String
}

type AddParticipantAdminPayload {
  availability: Availability!
  clientMutationId: String
}

input AddParticipantToBookingAsCoachInput {
  availabilityId: ID!
  participantId: ID!
  clientMutationId: String
}

type AddParticipantToBookingAsCoachPayload {
  availability: Availability!
  clientMutationId: String
}

input AddParticipantToMyBookingInput {
  availabilityId: ID!
  participantId: ID!
  clientMutationId: String
}

type AddParticipantToMyBookingPayload {
  availability: Availability!
  clientMutationId: String
}

input AddProductSelectionConditionInput {
  amount: Int!
  limitedCartDiscountId: ID!
  productId: ID!
  clientMutationId: String
}

type AddProductSelectionConditionPayload {
  limitedCartDiscount: LimitedCartDiscount!
  clientMutationId: String
}

type Address {
  lineOne: String!
  lineTwo: String!
  postalCode: String!
  city: String!
}

input AddressInput {
  lineOne: String!
  lineTwo: String!
  city: String!
  postalCode: String!
}

input AddRowToMatrixElementInput {
  rowTitle: String!
  correctAnswerContent: String!
  matrixElementId: ID!
  clientMutationId: String
}

type AddRowToMatrixElementPayload {
  eLearningContent: TreeNode!
  matrixElement: MatrixElement!
  clientMutationId: String
}

input AddUserToAccountAdminInput {
  accountId: ID!
  userId: ID!
  clientMutationId: String
}

type AddUserToAccountAdminPayload {
  userInAccount: UserInAccountEdge!
  clientMutationId: String
}

input AddWordNoteInput {
  note: String!
  wordId: ID!
  clientMutationId: String
}

type AddWordNotePayload {
  inventory: WordInventory!
  clientMutationId: String
}

input AddWordPackageRewardInput {
  data: WordPackageRewardDataInput!
  contentId: ID!
  clientMutationId: String
}

type AddWordPackageRewardPayload {
  content: TreeNode!
  clientMutationId: String
}

input AddWordProficienciesRewardInput {
  contentId: ID!
  clientMutationId: String
}

type AddWordProficienciesRewardPayload {
  content: TreeNode!
  clientMutationId: String
}

input AddWordToPackageInput {
  word: String!
  translation: String
  explanation: String!
  wordPackageId: ID!
  clientMutationId: String
}

type AddWordToPackagePayload {
  wordPackage: WordPackage!
  clientMutationId: String
}

input AddWrongAnswerInMatrixElementCellInput {
  wrongAnswerContent: String!
  matrixElementId: ID!
  matrixCellId: ID!
  clientMutationId: String
}

type AddWrongAnswerInMatrixElementCellPayload {
  eLearningContent: TreeNode!
  matrixElement: MatrixElement!
  clientMutationId: String
}

"""Data only accessible by the admin"""
type AdminMutationType {
  Hubspot: HubspotAdminMutationSchema!
  ElearningV2: ElearningV2AdminMutationSchema!
  Instructor: InstructorAdminMutationSchema!
  LicenseDefinition: LicenseDefinitionAdminMutationSchema!
  Vocab: VocabAdminMutationSchema!
  AvgsPotentialAnalysis: AvgsPotentialAnalysisAdminMutationSchema!
  Azav: AzavAdminMutationSchema!
  AsyncContent: AsyncContentAdminMutationSchema!
  Billing: BillingAdminMutationSchema!
  PublishingV2: PublishingV2AdminMutationSchema!
  Settings: SettingsAdminMutationSchema!
  FeatureToggle: FeatureToggleAdminMutationSchema!
  Trend: TrendAdminMutationSchema!
  Staging: StagingAdminMutationSchema!
  Email: EmailAdminMutationSchema!
  Auth: AuthAdminMutationSchema!
  Tag: TagAdminMutationSchema!
  Notification: NotificationAdminMutationSchema!
  Coaching: CoachingAdminMutationSchema!
  LearnV2: LearnV2AdminMutationSchema!
  CustomerFeedback: CustomerFeedbackAdminMutationSchema!
  Files: FilesAdminMutationSchema!
  Tree: TreeAdminMutationSchema!
  AcademiesTag: AcademiesTagAdminMutationSchema!
  Caching: CachingAdminMutationSchema!
  AccountBaseData: AccountBaseDataAdminMutationSchema!
}

"""Data only accessible by the admin"""
type AdminQueryType {
  Learnable: LearnableAdminSchema!
  Instructor: InstructorAdminSchema!
  Files: FilesAdminSchema!
  LicenseDefinition: LicenseDefinitionAdminSchema!
  Vocab: VocabAdminSchema!
  Reports: ReportsAdminSchema!
  AvgsPotentialAnalysis: AvgsPotentialAnalysisAdminSchema!
  Management: ManagementAdminSchema!
  AsyncContent: AsyncContentAdminSchema!
  AccountBaseData: AccountBaseDataAdminSchema!
  Billing: BillingAdminSchema!
  PublishingV2: PublishingV2AdminSchema!
  Settings: SettingsAdminSchema!
  FeatureToggle: FeatureToggleAdminSchema!
  Trend: TrendAdminSchema!
  Email: EmailAdminSchema!
  Auth: AuthAdminSchema!
  Tag: TagAdminSchema!
  Notification: NotificationAdminSchema!
  Coaching: CoachingAdminSchema!
  LearnV2: LearnV2AdminSchema!
  Tree: TreeAdminSchema!
  AcademiesTag: AcademiesTagAdminSchema!
}

type Advantage {
  icon: Icon
  heading: String!
  description: String!
}

input AdvantageInput {
  icon: Icon
  heading: String!
  description: String!
}

type AfterDateTimeVisibilityTreeConfig implements VisibilityTreeConfig {
  dateTime: ZonedDateTIme!

  """The ID of an object"""
  id: ID!
  configType: VisibilityTreeConfigType!
}

type AlwaysPassContentConfig implements PassContentConfig {
  """The ID of an object"""
  id: ID!
  configType: PassContentConfigType!
}

type AlwaysRestartContinueContentConfig implements ContinueContentConfig {
  """The ID of an object"""
  id: ID!
  configType: ContinueContentConfigType!
}

input AnonymizeAccountAsOwnerInput {
  clientMutationId: String
}

type AnonymizeAccountAsOwnerPayload {
  deletedIds: [ID!]!
  clientMutationId: String
}

input AnonymizeAccountInput {
  id: ID!
  clientMutationId: String
}

type AnonymizeAccountPayload {
  deletedIds: [ID!]!
  clientMutationId: String
}

input AnonymizeMyUserInput {
  clientMutationId: String
}

type AnonymizeMyUserPayload {
  clientMutationId: String
}

enum AnsweringTypeV2 {
  allowOnlyOneAnswer
  allowMultipleAnswersOnlySomeCorrectMustBeGiven
  allowMultipleAnswersAllCorrectMustBeGiven
}

type AnswerMatrixElementCell implements MatrixElementCell {
  correctAnswer: MatrixElementCellCorrectAnswer!
  wrongAnswers: [MatrixElementCellWrongAnswer!]!

  """The ID of an object"""
  id: ID!
  xIdx: Int!
  yIdx: Int!
  kind: MatrixElementCellKind!
}

type AnswerMatrixLearnElementCell implements MatrixLearnElementCell {
  answers: [MatrixLearnElementAnswer!]!
  xIdx: Int!
  yIdx: Int!
  kind: MatrixElementCellKind!
}

type AnswerOptionV2 {
  answer: String!
  isCorrect: Boolean!
  image: File
}

input AnswerOptionV2Input {
  answer: String!
  isCorrect: Boolean!
  imageRef: ID
}

type AnswerOptionWithoutCorrect {
  answer: String!
  image: File
}

type AppleIAPData implements PaymentProviderData {
  paymentMethod: PaymentMethodType!
  dataType: PaymentProviderDataType!
  receipt: String!
}

interface AssignmentRule {
  """The ID of an object"""
  id: ID!
  licenseGroupingId: ID!
  accountRef: ID!
}

"""Data only accessible by the admin"""
type AsyncContentAdminMutationSchema {
  createUploadAsyncElement(input: CreateUploadAsyncElementInput!): CreateUploadAsyncElementPayload
  editUploadAsyncElement(input: EditUploadAsyncElementInput!): EditUploadAsyncElementPayload
  evaluateUploadAsyncElementTask(input: EvaluateUploadAsyncElementTaskInput!): EvaluateUploadAsyncElementTaskPayload
}

"""Data only accessible by the admin"""
type AsyncContentAdminSchema {
  GetAsyncElementTasks(before: String, after: String, first: Int, last: Int): AsyncElementTasksConnection!
}

type AsyncContentMutations {
  submitUploadAsyncElement(input: SubmitUploadAsyncElementInput!): SubmitUploadAsyncElementPayload
}

interface AsyncContentSubmissionDefinition {
  element: AsyncLearnElement
  status: ContentSubmissionStatus!
  contentKind: ContentKind!
}

type AsyncContentTypeDefinition implements ContentTypeDefinition & TypeDefinition {
  element: AsyncElement
  extension: ContentExtension!
  continueConfig: ContinueContentConfig!
  passConfig: PassContentConfig!
  restartIfFailedConfigs: [RestartIfFailedContentConfig!]!
  restartIfPassedConfig: RestartIfPassedContentConfig!
  rewardConfig: RewardContentConfig!
  rewards: [Reward!]!
  startConfigs: [StartContentConfig!]!
  contentKind: ContentKind!
  definitionType: TypeDefinitionType!
}

interface AsyncElement {
  """The ID of an object"""
  id: ID!
  title: String!
  taskDescription: String
  assignedEvaluator: User
  kind: AsyncElementKind!
}

enum AsyncElementKind {
  Upload
}

interface AsyncElementTask {
  id: ID!
  submissionInfo: AsyncElementTaskSubmissionInfo!
  elementKind: AsyncElementKind!
  extension: AsyncElementTaskExtension!
  assignedEvaluator: User
  status: AsyncElementTaskStatus!
}

interface AsyncElementTaskExtension {
  doNotUse: String!
}

type AsyncElementTaskExtensionImpl implements AsyncElementTaskExtension {
  hierarchy: AsyncElementTaskHierarchy
  doNotUse: String!
}

type AsyncElementTaskHierarchy {
  rootTitle: String!
  branchTitle: String!
  asyncContentTitle: String!
}

"""A connection to a list of items."""
type AsyncElementTasksConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [AsyncElementTasksEdge]
}

"""An edge in a connection."""
type AsyncElementTasksEdge {
  """The item at the end of the edge."""
  node: AsyncElementTask!

  """A cursor for use in pagination."""
  cursor: String!
}

enum AsyncElementTaskStatus {
  Fresh
  Evaluated
}

type AsyncElementTaskSubmissionInfo {
  at: ZonedDateTIme!
  by: User
}

interface AsyncLearnElement {
  """The ID of an object"""
  id: ID!
  title: String!
  taskDescription: String!
  elementKind: AsyncElementKind!
}

enum AttachmentKind {
  DefaultFile
}

interface AttachmentV2 {
  """The ID of an object"""
  id: ID!
  title: String
  description: String
  kind: AttachmentKind!
}

"""Data only accessible by the admin"""
type AuthAdminMutationSchema {
  loginAsUserJwt(input: LoginAsUserJwtInput!): LoginAsUserJwtPayload
  anonymizeUser(input: DeleteUserInput!): DeleteUserPayload
  editUser(input: EditUserInput!): EditUserPayload
  triggerResetPassword(input: TriggerResetPasswordInput!): TriggerResetPasswordPayload
  triggerResendActivation(input: TriggerResendActivationInput!): TriggerResendActivationPayload
  createAccount(input: CreateAccountInput!): CreateAccountPayload
  setAccountName(input: SetAccountNameInput!): SetAccountNamePayload
  setAccountGroups(input: SetAccountGroupsInput!): SetAccountGroupsPayload
  anonymizeAccountAdmin(input: AnonymizeAccountInput!): AnonymizeAccountPayload
  addUserToAccount(input: AddUserToAccountAdminInput!): AddUserToAccountAdminPayload
  createUserInAccount(input: CreateUserInAccountInput!): CreateUserInAccountPayload
  removeUserFromAccount(input: RemoveUserFromAccountInput!): RemoveUserFromAccountPayload
  setUserInAccountGroups(input: SetUserInAccountGroupsInput!): SetUserInAccountGroupsPayload
}

"""Data only accessible by the admin"""
type AuthAdminSchema {
  GetUserInAccountGroups(id: ID!): [UserInAccountGroup!]!
  SearchEditors(before: String, after: String, first: Int, last: Int, filterByNameOrEmail: String): UserConnection!
  SelectUsers(before: String, after: String, first: Int, last: Int, filterByNameOrEmail: String, filterByAccountId: ID): UserConnection!
  Users(before: String, after: String, first: Int, last: Int, filterByNameOrEmail: String, filterByAccountId: ID): UserConnection!
  SelectAccounts(before: String, after: String, first: Int, last: Int, ids: [ID!]!, nameOpt: String): AccountConnection!
  Accounts(before: String, after: String, first: Int, last: Int, name: String): AccountConnection!
}

type AuthMutations {
  logoutJwt(input: LogoutJwtInput!): LogoutJwtPayload
  registerUser(input: RegisterUserInput!): RegisterUserPayload
  activateUser(input: ActivateUserInput!): ActivateUserPayload
  login(input: LoginInput!): LoginPayload
  loginJwt(input: LoginJwtInput!): LoginJwtPayload
  switchAccount(input: SwitchAccountInput!): SwitchAccountPayload
  forgotPassword(input: ForgotPasswordInput!): ForgotPasswordPayload
  resetPasswordAndActivate(input: ResetPasswordAndActivateInput!): ResetPasswordAndActivatePayload
  resendActivation(input: ResendActivationInput!): ResendActivationPayload
  setAccountNameUser(input: SetAccountNameUserInput!): SetAccountNameUserPayload
  acceptInvitation(input: AcceptInvitationInput!): AcceptInvitationPayload
  acceptInvitationWithNewUser(input: AcceptInviteWithNewUserInput!): AcceptInviteWithNewUserPayload
}

type AuthQueries {
  InvitationByToken(token: String!): Invitation
}

"""Data partaining to the current user"""
type AuthViewerMutationSchema {
  anonymizeMyUser(input: AnonymizeMyUserInput!): AnonymizeMyUserPayload
  leaveAccount(input: LeaveAccountInput!): LeaveAccountPayload
}

"""Data partaining to the current user"""
type AuthViewerSchema {
  currentUser: CurrentUser
}

type Availability implements Node {
  """The ID of an object"""
  id: ID!
  booking: BookingInterface!
  data: AvailabilityData!
  coachProfile: CoachProfile
  feedback: CoachFeedback
}

"""A connection to a list of items."""
type AvailabilityConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [AvailabilityEdge]
}

type AvailabilityData {
  startDateTime: ZonedDateTIme!
  endDateTime: ZonedDateTIme!
}

input AvailabilityDataInput {
  startDateTime: ZonedDateTIme!
  endDateTime: ZonedDateTIme!
}

"""An edge in a connection."""
type AvailabilityEdge {
  """The item at the end of the edge."""
  node: Availability!

  """A cursor for use in pagination."""
  cursor: String!
}

type AvailabilitySchedule implements Node {
  """The ID of an object"""
  id: ID!
  data: ScheduleData!
  coachRef: ID!
}

"""A connection to a list of items."""
type AvailabilityScheduleConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [AvailabilityScheduleEdge]
}

type AvailabilityScheduleDayAndTimes {
  timeSlots: [LocalTime!]!
  dayOfWeek: DayOfWeek!
}

"""An edge in a connection."""
type AvailabilityScheduleEdge {
  """The item at the end of the edge."""
  node: AvailabilitySchedule!

  """A cursor for use in pagination."""
  cursor: String!
}

type AVGSPotentialAnalysis_AcceptedForUser implements AVGSPotentialAnalysis_ForUser {
  client: User
  kind: AVGSPotentialAnalysis_ForUserKind!
}

type AVGSPotentialAnalysis_Dimension {
  dimensionId: Int!
  dimensionText: String!
  questions: [PotentialAnalysisQuestion!]!
}

interface AVGSPotentialAnalysis_ForUser {
  kind: AVGSPotentialAnalysis_ForUserKind!
}

enum AVGSPotentialAnalysis_ForUserKind {
  AcceptedForUser
  InvitedForUser
}

type AVGSPotentialAnalysis_Info {
  """The ID of an object"""
  id: ID!
  numAvailableLicenses: Int!
}

type AVGSPotentialAnalysis_InvitedForUser implements AVGSPotentialAnalysis_ForUser {
  email: String!
  kind: AVGSPotentialAnalysis_ForUserKind!
}

type AVGSPotentialAnalysis_LearnPotentialAnalysis {
  """The ID of an object"""
  id: ID!
  modules: [AVGSPotentialAnalysis_Module!]!
  isFinished: Boolean!
}

type AVGSPotentialAnalysis_Module {
  moduleId: Int!
  moduleText: String!
  dimensions: [AVGSPotentialAnalysis_Dimension!]!
}

type AVGSPotentialAnalysis_PotentialAnalysis implements Node {
  """The ID of an object"""
  id: ID!
  client: AVGSPotentialAnalysis_ForUser!
  coach: User
  replacementCoach: User
  coachAccount: Account
  linkToPotentialAnalysisOrInvitation: String!
  createdAt: ZonedDateTIme!
  isFinished: Boolean!
  modules: [AVGSPotentialAnalysis_Module!]!
  base64EncodedReport: String
}

"""Data only accessible by the admin"""
type AvgsPotentialAnalysisAdminMutationSchema {
  createPotentialAnalysis(input: CreatePotentialAnalysisInput!): CreatePotentialAnalysisPayload
  changeReplacementCoach(input: ChangeReplacementCoachInput!): ChangeReplacementCoachPayload
  changeInvitedForUser(input: ChangeInvitedForUserInput!): ChangeInvitedForUserPayload
  transformPrivateAccountToAVGSAccount(input: TransformPrivateAccountToAVGSAccountInput!): TransformPrivateAccountToAVGSAccountPayload
  transformBusinessAccountToAVGSAccount(input: TransformBusinessAccountToAVGSAccountInput!): TransformBusinessAccountToAVGSAccountPayload
}

"""Data only accessible by the admin"""
type AvgsPotentialAnalysisAdminSchema {
  AVGSPotentialAnalysis(before: String, after: String, first: Int, last: Int): PotentialAnalysisConnection!
  AvailableModulesAndDimensions(before: String, after: String, first: Int, last: Int): [AVGSPotentialAnalysis_Module!]!
  Info: AVGSPotentialAnalysis_Info
  SearchAVGSCoaches(before: String, after: String, first: Int, last: Int, accountId: ID!, filterByNameOrEmail: String): UserConnection!
}

type AVGSPotentialAnalysisLicenseDefinitionData implements LicenseDefinitionData {
  name: String!
  kind: LicenseDefinitionDataKind!
}

input AVGSPotentialAnalysisLicenseDefinitionDataInput {
  name: String!
}

type AvgsPotentialAnalysisMutations {
  setAnswerInMultipleChoiceFreeTextQuestion(input: SetAnswerInMultipleChoiceFreeTextQuestionInput!): SetAnswerInMultipleChoiceFreeTextQuestionPayload
  setAnswerInMultipleChoiceQuestion(input: SetAnswerInMultipleChoiceQuestionInput!): SetAnswerInMultipleChoiceQuestionPayload
  setAnswerInScaleQuestion(input: SetAnswerInScaleQuestionInput!): SetAnswerInScaleQuestionPayload
  setAnswerInSingleChoiceFreeTextQuestion(input: SetAnswerInSingleChoiceFreeTextQuestionInput!): SetAnswerInSingleChoiceFreeTextQuestionPayload
  setAnswerInSingleChoiceQuestion(input: SetAnswerInSingleChoiceQuestionInput!): SetAnswerInSingleChoiceQuestionPayload
  setAnswerInTextQuestion(input: SetAnswerInTextQuestionInput!): SetAnswerInTextQuestionPayload
}

type AvgsPotentialAnalysisQueries {
  AVGSAccounts(before: String, after: String, first: Int, last: Int, filterByName: String): AccountConnection!
  LearnPotentialAnalysis(before: String, after: String, first: Int, last: Int, learnPotentialAnalysisId: ID!): AVGSPotentialAnalysis_LearnPotentialAnalysis
}

"""Data only accessible by the admin"""
type AzavAdminMutationSchema {
  transformBusinessAccountToAZAVAccount(input: TransformBusinessAccountToAZAVAccountInput!): TransformBusinessAccountToAZAVAccountPayload
  transformPrivateAccountToAZAVAccount(input: TransformPrivateAccountToAZAVAccountInput!): TransformPrivateAccountToAZAVAccountPayload
}

interface baseData {
  city: String
  street: String
  houseNumber: String
  postalCode: String
  countryCode: CountryCode
}

type BaseData {
  birthPlace: String!
  nationality: String!
  address: Address!
  birthDate: LocalDate!
  gender: Gender!
}

"""
The `BigDecimal` scalar type represents signed fractional values with arbitrary precision.
"""
scalar BigDecimal

"""Data only accessible by the admin"""
type BillingAdminMutationSchema {
  createContractPartner(input: CreateContractPartnerInput!): CreateContractPartnerPayload
  editContractPartnerData(input: EditContractPartnerDataInput!): EditContractPartnerDataPayload
  deleteContractPartner(input: DeleteContractPartnerInput!): DeleteContractPartnerPayload
  createStripeConnectAccount(input: CreateStripeConnectAccountInput!): CreateStripeConnectAccountPayload
  createAccountGroupProduct(input: CreateAccountGroupProductInput!): CreateAccountGroupProductPayload
  editAccountGroupProduct(input: EditAccountGroupProductInput!): EditAccountGroupProductPayload
  createEuroDiscountAction(input: CreateEuroDiscountActionInput!): CreateEuroDiscountActionPayload
  createPercentageDiscountAction(input: CreatePercentageDiscountActionInput!): CreatePercentageDiscountActionPayload
  createDiscountCode(input: CreateDiscountCodeInput!): CreateDiscountCodePayload
  createRandomDiscountCodes(input: CreateRandomDiscountCodesInput!): CreateRandomDiscountCodesPayload
  deleteDiscountCode(input: DeleteDiscountCodeInput!): DeleteDiscountCodePayload
  editEuroDiscountAction(input: EditEuroDiscountActionInput!): EditEuroDiscountActionPayload
  deleteDiscountAction(input: DeleteDiscountActionInput!): DeleteDiscountActionPayload
  editPercentageDiscountAction(input: EditPercentageDiscountActionInput!): EditPercentageDiscountActionPayload
  editDiscountCode(input: EditDiscountCodeInput!): EditDiscountCodePayload
  generateAbsoluteCartLink(input: GenerateAbsoluteCartLinkInput!): GenerateAbsoluteCartLinkPayload
  createLimitedCartDiscount(input: CreateLimitedCartDiscountInput!): CreateLimitedCartDiscountPayload
  deleteCondition(input: DeleteConditionInput!): DeleteConditionPayload
  editLimitedCartDiscount(input: EditLimitedCartDiscountInput!): EditLimitedCartDiscountPayload
  deleteLimitedCartDiscount(input: DeleteLimitedCartDiscountInput!): DeleteLimitedCartDiscountPayload
  addProductSelectionCondition(input: AddProductSelectionConditionInput!): AddProductSelectionConditionPayload
  editProductSelectionCondition(input: EditProductSelectionConditionInput!): EditProductSelectionConditionPayload
  createPlacementProduct(input: CreatePlacementProductInput!): CreatePlacementProductPayload
  editPlacementProduct(input: EditPlacementProductInput!): EditPlacementProductPayload
  createExternalLicensePool(input: CreateExternalLicensePoolInput!): CreateExternalLicensePoolPayload
  editExternalLicensePool(input: EditExternalLicensePoolInput!): EditExternalLicensePoolPayload
  deleteExternalLicensePool(input: DeleteExternalLicensePoolInput!): DeleteExternalLicensePoolPayload
  createExternalLicense(input: CreateExternalLicenseInput!): CreateExternalLicensePayload
  editExternalLicense(input: EditExternalLicenseInput!): EditExternalLicensePayload
  deleteExternalLicense(input: DeleteExternalLicenseInput!): DeleteExternalLicensePayload
  issueExternalLicense(input: IssueExternalLicenseInput!): IssueExternalLicensePayload
  createLicenses(input: CreateLicensesInput!): CreateLicensesPayload
  deleteLicense(input: DeleteLicenseInput!): DeleteLicensePayload
  createLicenseProduct(input: CreateLicenseProductInput!): CreateLicenseProductPayload
  editLicenseProduct(input: EditLicenseProductInput!): EditLicenseProductPayload
  deleteProduct(input: DeleteProductInput!): DeleteProductPayload
}

"""Data only accessible by the admin"""
type BillingAdminSchema {
  ContractPartners(before: String, after: String, first: Int, last: Int, name: String): ContractPartnersConnection!
  DiscountsMultiselect(before: String, after: String, first: Int, last: Int, ids: [ID!]!, codeOpt: String): DiscountCodesV2Connection!
  DiscountActions(before: String, after: String, first: Int, last: Int, filterByDiscountTypeKind: DiscountTypeKindInput, filterByActionTitle: String, filterByCode: String): DiscountActionsConnection!
  selectDiscountCodes(before: String, after: String, first: Int, last: Int, code: String): DiscountCodesV2Connection!
  Orders(before: String, after: String, first: Int, last: Int, userId: ID, accountId: ID, email: String, username: String): OrdersConnection!
  LimitedCartDiscounts(before: String, after: String, first: Int, last: Int, title: String): LimitedCartDiscountConnection!
  GetExternalLicensePools(before: String, after: String, first: Int, last: Int, nameOpt: String): ExternalLicensePoolsConnection!
  GetExternalLicenses(before: String, after: String, first: Int, last: Int, name: String, isIssued: Boolean, pool: ID): ExternalLicensesConnection!
  SearchProducts(before: String, after: String, first: Int, last: Int, titleOpt: String, isHiddenOpt: Boolean, isLicenseProductOpt: Boolean): ProductsConnection!
}

interface BillingDetails {
  city: String!
  customerType: CustomerType!
  street: String!
  country: String!
  firstName: String!
  houseNumber: String!
  invoiceEmail: String!
  lastName: String!
  postalCode: String!
  salutation: SalutationType!
  phoneNumber: String!
}

type BillingDetailsUpdate implements HistoryEventInterface {
  kind: HistoryEventType!
}

type BillingMutations {
  bookTree(input: BookTreeInput!): BookTreePayload
  updatePrivateBillingDetailsAndInitiateCheckout(input: UpdatePrivateBillingDetailsAndInitiateCheckoutInput!): UpdatePrivateBillingDetailsAndInitiateCheckoutPayload
  updateBusinessBillingDetailsAndInitiateCheckout(input: UpdateBusinessBillingDetailsAndInitiateCheckoutInput!): UpdateBusinessBillingDetailsAndInitiateCheckoutPayload
  updateBusinessBillingDetails(input: UpdateBusinessBillingDetailsInput!): UpdateBusinessBillingDetailsPayload
  updatePrivateBillingDetails(input: UpdatePrivateBillingDetailsInput!): UpdatePrivateBillingDetailsPayload
  updateCart(input: UpdateCartInput!): UpdateCartPayload
  createOrder(input: CreateOrderInput!): CreateOrderPayload
  payOrder(input: PayOrderInput!): PayOrderPayload
  payOrderViaIAP(input: PayOrderViaIAPInput!): PayOrderViaIAPPayload
  changePaymentDate(input: ChangePaymentDateInput!): ChangePaymentDatePayload
  changePaymentMethod(input: ChangePaymentMethodInput!): ChangePaymentMethodPayload
}

"""Data partaining to the current user"""
type BillingViewerSchema {
  ViewerOrders(before: String, after: String, first: Int, last: Int): OrdersConnection!
  LicensesGroupedByDefinition(before: String, after: String, first: Int, last: Int): LicensesGroupedByDefinitionConnection!
}

type BlockedByTreeContentNodeAdvancementResult implements ContentNodeAdvancementResult {
  status: ContentNodeAdvancementStatus!
}

type BlockoutDate {
  from: ZonedDateTIme!
  to: ZonedDateTIme!
}

input BlockoutDateInput {
  from: ZonedDateTIme!
  to: ZonedDateTIme!
}

type BlockPermanentlyRestartIfFailedContentConfig implements RestartIfFailedContentConfig {
  maximumTries: Int!

  """The ID of an object"""
  id: ID!
  configType: RestartIfFailedContentConfigType!
}

type BlockTemporarilyRestartIfFailedContentConfig implements RestartIfFailedContentConfig {
  daysToBlock: Int!

  """The ID of an object"""
  id: ID!
  configType: RestartIfFailedContentConfigType!
}

input BookCoachingInput {
  availabilityId: ID!
  coachingId: ID!
  clientMutationId: String
}

type BookCoachingPayload {
  availability: Availability!
  clientMutationId: String
}

type BookedForGroup implements BookingInterface {
  kind: BookingKind!
  participants: [Participant!]!
  offer: CoachingOffer
  msTeamsLink: String!
}

type BookedOneToOne implements BookingInterface {
  kind: BookingKind!
  participant: Participant!
  offer: CoachingOffer
  msTeamsLink: String!
}

interface BookingInterface {
  kind: BookingKind!
}

enum BookingKind {
  NotBooked
  BookedOneToOne
  BookedForGroup
}

input BookTreeInput {
  rootId: ID!
  clientMutationId: String
}

type BookTreePayload {
  root: LearnOpportunityV2!
  clientMutationId: String
}

enum Branch {
  itAndSoftwareDevelopment
  analysisAndStatistic
  productManagement
  personnelAndHr
  marketingAndAdvertising
  graphicsAndDesign
  financeAccountingAndControlling
  healthMedicineAndSocialAffairs
  adviceAndConsulting
  processPlanningAndQualityAssurance
  legalServices
  otherFieldsOfActivity
}

type BranchTypeDefinition implements TypeDefinition {
  childRefs: [ID!]!
  definitionType: TypeDefinitionType!
}

type BusinessBaseData implements baseData {
  companyName: String
  billingOffice: String
  companyLegalForm: CompanyType
  invoiceEmail: String
  phoneNumber: String
  taxData: TaxData
  accountData: AccountData
  city: String
  street: String
  houseNumber: String
  postalCode: String
  countryCode: CountryCode
}

input BusinessBaseDataInput {
  city: String!
  street: String!
  houseNumber: String!
  postalCode: String!
  countryCode: CountryCode!
  phoneNumber: String!
  companyName: String!
  billingOffice: String!
  companyLegalForm: CompanyType!
  invoiceEmail: String!
  taxData: TaxDataInput!
  accountData: AccountDataInput!
}

type BusinessBaseDataOutput {
  accountName: String!
  city: String!
  street: String!
  houseNumber: String!
  postalCode: String!
  countryCode: CountryCode!
  companyName: String!
  billingOffice: String!
  companyLegalForm: CompanyType!
  invoiceEmail: String!
  phoneNumber: String!
  taxData: TaxData!
  accountData: AccountData!
}

type BusinessBillingDetails implements BillingDetails {
  companyDetails: String
  customerType: CustomerType!
  invoiceEmail: String!
  houseNumber: String!
  companyType: CompanyType!
  salutation: SalutationType!
  postalCode: String!
  firstName: String!
  lastName: String!
  country: String!
  company: String!
  street: String!
  city: String!
  phoneNumber: String!
}

type BusinessData {
  iban: String
  bic: String
  taxNumber: String
  insuranceNumber: String
  employerNumber: String
}

input BusinessDataInput {
  iban: String
  bic: String
  taxNumber: String
  insuranceNumber: String
  employerNumber: String
}

"""Data only accessible by the admin"""
type CachingAdminMutationSchema {
  clearCache(input: ClearCacheInput!): ClearCachePayload
}

type CalendarWeekAndYear {
  calendarWeek: Int!
  calendarYear: Int!
}

type CanAfterStartingTreeStartContentConfig implements StartContentConfig {
  """The ID of an object"""
  id: ID!
  configType: StartContentConfigType!
}

type CanBeRestartedAfterFailedContentNodeAdvancementResult implements ContentNodeAdvancementResult {
  status: ContentNodeAdvancementStatus!
}

type CanBeRestartedAfterPassedContentNodeAdvancementResult implements ContentNodeAdvancementResult {
  status: ContentNodeAdvancementStatus!
}

type CanBeStartedContentNodeAdvancementResult implements ContentNodeAdvancementResult {
  status: ContentNodeAdvancementStatus!
}

type CanBeStartedViewerTreeState implements ViewerTreeState {
  kind: ViewerTreeStateKind!
}

input CancelBookingAsCoachInput {
  cancellationComment: String
  availabilityId: ID!
  clientMutationId: String
}

type CancelBookingAsCoachPayload {
  availability: Availability!
  clientMutationId: String
}

input CancelBookingAsParticipantInput {
  availabilityId: ID!
  clientMutationId: String
}

type CancelBookingAsParticipantPayload {
  availability: Availability!
  clientMutationId: String
}

type CanIfInTreeFlowStartContentConfig implements StartContentConfig {
  """The ID of an object"""
  id: ID!
  configType: StartContentConfigType!
}

type CanIfUnlockedStartContentConfig implements StartContentConfig {
  """The ID of an object"""
  id: ID!
  configType: StartContentConfigType!
}

type CanNotBeRestartedAfterFailedContentNodeAdvancementResult implements ContentNodeAdvancementResult {
  configResults: [RestartIfFailedContentConfigResult!]!
  status: ContentNodeAdvancementStatus!
}

type CanNotBeRestartedAfterPassedContentNodeAdvancementResult implements ContentNodeAdvancementResult {
  reasonConfigTypes: [RestartIfPassedContentConfigType!]!
  status: ContentNodeAdvancementStatus!
}

type CanNotBeStartedContentNodeAdvancementResult implements ContentNodeAdvancementResult {
  reasonConfigTypes: [StartContentConfigType!]!
  status: ContentNodeAdvancementStatus!
}

type CanNotBeStartedViewerTreeState implements ViewerTreeState {
  reasonConfigTypes: [StartTreeConfigType!]!
  kind: ViewerTreeStateKind!
}

type CanNotRestartIfFailedContentConfig implements RestartIfFailedContentConfig {
  """The ID of an object"""
  id: ID!
  configType: RestartIfFailedContentConfigType!
}

type CanNotRestartIfPassedContentConfig implements RestartIfPassedContentConfig {
  """The ID of an object"""
  id: ID!
  configType: RestartIfPassedContentConfigType!
}

type CanNotStartContentConfig implements StartContentConfig {
  """The ID of an object"""
  id: ID!
  configType: StartContentConfigType!
}

type CanNotStartTreeConfig implements StartTreeConfig {
  """The ID of an object"""
  id: ID!
  configType: StartTreeConfigType!
}

type CanRestartIfPassedContentConfig implements RestartIfPassedContentConfig {
  """The ID of an object"""
  id: ID!
  configType: RestartIfPassedContentConfigType!
}

input CanShowElementAnswerInput {
  contentSubmissionId: ID!
  clientMutationId: String
}

type CanShowElementAnswerPayload {
  can: Boolean!
  clientMutationId: String
}

input CanSubmitElementInput {
  contentSubmissionId: ID!
  elementId: ID!
  clientMutationId: String
}

type CanSubmitElementPayload {
  can: Boolean!
  clientMutationId: String
}

type Cart {
  discountCodeRefusals: [Refusal!]!
  paymentDates: [ZonedDateTIme!]!
  items: [Item!]!
  totals: CartTotals!
  selection: Selection!
  taxTotals: TaxTotals
  otherAvailableProducts(before: String, after: String, first: Int, last: Int): ProductsConnection!
}

type CartBulkDiscount implements Item {
  discountPercentage: BigDecimal!
  eligibleProductCount: Int!
  itemType: ItemType!
}

type CartClickout {
  absoluteLink: String!
  relativeLink: String!
  netPrice: BigDecimal!
}

type CartDiscount implements Item {
  validUntil: ZonedDateTIme
  value: DiscountActionCalcType!
  code: String!
  title: String!
  itemType: ItemType!
}

type CartGlobalDiscount implements Item {
  value: DiscountActionCalcType!
  title: String!
  itemType: ItemType!
}

type CartLimitedDiscount implements Item {
  value: DiscountActionCalcType!
  title: String!
  itemType: ItemType!
}

input CartLinkProductsInput {
  amount: Int!
  productId: ID!
}

type CartProduct implements Item {
  amount: Int!
  totalPrice: Price!
  individualPrice: Price!
  product: Product
  itemType: ItemType!
}

input CartSelectionInput {
  selectedProducts: [SelectedProductInput!]!
  selectedDiscountCodes: [String!]!
  createdByUser: ID
}

type CartTotals {
  appliedDiscount: Price
  withoutDiscounts: Price!
  includingAllDiscounts: Price!
  appliedDiscountPercentage: BigDecimal
  appliedMoneyDiscount: BigDecimal
  monthlyOptions: [MonthlyOption!]!
}

type CartUpdate implements HistoryEventInterface {
  kind: HistoryEventType!
}

type CategoryResult {
  name: String!
  result: Float
  benchmark: Float
}

input ChangeInvitedForUserInput {
  newClientEmail: String!
  potentialAnalysisId: ID!
  clientMutationId: String
}

type ChangeInvitedForUserPayload {
  potentialAnalysis: AVGSPotentialAnalysis_PotentialAnalysis!
  clientMutationId: String
}

input ChangePaymentDateInput {
  orderId: ID!
  paymentDate: ZonedDateTIme!
  clientMutationId: String
}

type ChangePaymentDatePayload {
  order: Order!
  clientMutationId: String
}

input ChangePaymentMethodInput {
  paymentType: PaymentType!
  paymentMethodType: PaymentMethodType!
  rateCount: Int
  orderId: ID!
  clientMutationId: String
}

type ChangePaymentMethodPayload {
  order: Order!
  clientMutationId: String
}

input ChangeReplacementCoachInput {
  newReplacementCoachId: ID
  potentialAnalysisId: ID!
  clientMutationId: String
}

type ChangeReplacementCoachPayload {
  edge: PotentialAnalysisEdge!
  clientMutationId: String
}

type ChildStructureDefinition implements StructureDefinition {
  title: String!
  coordinates: CoordinatesV2!
  definitionType: StructureType!
}

input CleanUpUserInputRelatedToStagingInput {
  clientMutationId: String
}

type CleanUpUserInputRelatedToStagingPayload {
  clientMutationId: String
}

input ClearCacheInput {
  clientMutationId: String
}

type ClearCachePayload {
  clientMutationId: String
}

input CloneTreeInput {
  rootNodeId: ID!
  clientMutationId: String
}

type CloneTreePayload {
  clonedRootNode: TreeNodesEdge!
  clientMutationId: String
}

type ClozeAnswer {
  """The ID of an object"""
  id: ID!
  text: String!
}

type ClozePart implements ClozeTextPart {
  """The ID of an object"""
  id: ID!
  kind: ClozeTextPartKind!
}

type ClozeTextElementV2 implements ElementV2 {
  title: String!
  additionalWords: [String!]!
  text: String!

  """The ID of an object"""
  id: ID!
  elementType: ElementTypeV2!
  extension: ElementExtension!
}

type ClozeTextInputElementState implements InputElementState & ElementState {
  checkedAnswers: [ID!]!
  element: LearnElement!
  kind: ElementStateKind!
}

type ClozeTextLearnElement implements LearnElement {
  title: String!
  parts: [ClozeTextPart!]!
  shuffledAnswers: [ClozeAnswer!]!

  """The ID of an object"""
  id: ID!
  elementType: ElementTypeV2!
}

interface ClozeTextPart {
  """The ID of an object"""
  id: ID!
  kind: ClozeTextPartKind!
}

enum ClozeTextPartKind {
  cloze
  text
}

type ClozeTextShowAnswerElementState implements ShowAnswerElementState & ElementState {
  correctAnswers: [ID!]!
  lastCheckedAnswers: [ID!]!
  element: LearnElement!
  kind: ElementStateKind!
}

type CoachFeedback implements Node {
  """The ID of an object"""
  id: ID!
  data: CoachingFeedbackData!
  createdAt: ZonedDateTIme!
  coach: User
  feedbackGiver: User
}

"""A connection to a list of items."""
type CoachFeedbackConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CoachFeedbackEdge]
}

"""An edge in a connection."""
type CoachFeedbackEdge {
  """The item at the end of the edge."""
  node: CoachFeedback!

  """A cursor for use in pagination."""
  cursor: String!
}

"""Data only accessible by the admin"""
type CoachingAdminMutationSchema {
  addHideVisibilityCoachingConfig(input: AddHideVisibilityCoachingConfigInput!): AddHideVisibilityCoachingConfigPayload
  editCoachingOfferParticipationCertificate(input: EditCoachingOfferParticipationCertificateInput!): EditCoachingOfferParticipationCertificatePayload
  addOnlyAZAVAccountVisibilityCoachingConfig(input: AddOnlyAZAVAccountVisibilityCoachingConfigInput!): AddOnlyAZAVAccountVisibilityCoachingConfigPayload
  createCoachProfile(input: CreateCoachProfileInput!): CreateCoachProfilePayload
  editBaseData(input: EditBaseDataInput!): EditBaseDataPayload
  editProfileData(input: EditProfileDataInput!): EditProfileDataPayload
  editBusinessData(input: EditBusinessDataInput!): EditBusinessDataPayload
  deleteCoachProfile(input: DeleteCoachProfileInput!): DeleteCoachProfilePayload
  createAvailability(input: CreateAvailabilityInput!): CreateAvailabilityPayload
  editAvailability(input: EditAvailabilityInput!): EditAvailabilityPayload
  deleteAvailability(input: DeleteAvailabilityInput!): DeleteAvailabilityPayload
  editAvailabilitySchedule(input: EditAvailabilityScheduleInput!): EditAvailabilitySchedulePayload
  addOnlyWithLicenseVisibilityCoachingConfig(input: AddOnlyWithLicenseVisibilityCoachingConfigInput!): AddOnlyWithLicenseVisibilityCoachingConfigPayload
  addOnlyBusinessAccountVisibilityCoachingConfig(input: AddOnlyBusinessAccountVisibilityCoachingConfigInput!): AddOnlyBusinessAccountVisibilityCoachingConfigPayload
  createCoachingOffer(input: CreateCoachingOfferInput!): CreateCoachingOfferPayload
  editOfferDescription(input: EditOfferDescriptionInput!): EditOfferDescriptionPayload
  deleteCoachingOffer(input: DeleteCoachingOfferInput!): DeleteCoachingOfferPayload
  editGroupSetting(input: EditOneToOneSettingInput!): EditOneToOneSettingPayload
  editAssociatedCoaches(input: EditAssociatedCoachesInput!): EditAssociatedCoachesPayload
  editCoachingRemuneration(input: EditRenumerationInput!): EditRenumerationPayload
  removeVisibilityCoachingConfig(input: RemoveVisibilityCoachingConfigInput!): RemoveVisibilityCoachingConfigPayload
  registerParticipationAdmin(input: RegisterParticipationAdminInput!): RegisterParticipationAdminPayload
  addParticipant(input: AddParticipantAdminInput!): AddParticipantAdminPayload
  removeParticipant(input: RemoveParticipantAdminInput!): RemoveParticipantAdminPayload
}

"""Data only accessible by the admin"""
type CoachingAdminSchema {
  CoachStatements(before: String, after: String, first: Int, last: Int, filterByAccountId: ID): CoachStatementConnection!
  CoachProfiles(before: String, after: String, first: Int, last: Int, filterByUserId: ID, userName: String): CoachProfileWithCoachingsConnection!
  Availabilities(before: String, after: String, first: Int, last: Int, filterByCoachIds: [ID!], filterByParticipantIds: [ID!], onlyNeedConfirmation: Boolean, onlyBooked: Boolean, onlyFree: Boolean, filterByMinDate: LocalDate, filterByMaxDate: LocalDate): AvailabilityConnection!
  AvailabilitySchedules(before: String, after: String, first: Int, last: Int, filterByCoaches: ID): AvailabilityScheduleConnection!
  FreeCalendarWeeks(coachUserId: ID): [CalendarWeekAndYear!]!
  CoachingOffers(before: String, after: String, first: Int, last: Int, name: String): CoachingOfferConnection!
  GetCoachingOffer(before: String, after: String, first: Int, last: Int, id: ID!): CoachingOffer
  CoachFeedbacks(before: String, after: String, first: Int, last: Int): CoachFeedbackConnection!
}

type CoachingFeedbackData {
  score: Int!
  comment: String
}

type CoachingLicenseDefinitionData implements LicenseDefinitionData {
  coachingInfo: LicenseDefinitionCoachingInfo
  name: String!
  kind: LicenseDefinitionDataKind!
}

input CoachingLicenseDefinitionDataInput {
  name: String!
  coachingId: ID!
}

type CoachingMutations {
  editMyProfileData(input: EditMyProfileDataInput!): EditMyProfileDataPayload
  editMyBusinessData(input: EditMyBusinessDataInput!): EditMyBusinessDataPayload
  editMyBaseData(input: EditMyBaseDataInput!): EditMyBaseDataPayload
  createMyAvailability(input: CreateMyAvailabilityInput!): CreateMyAvailabilityPayload
  editMyAvailability(input: EditMyAvailabilityInput!): EditMyAvailabilityPayload
  deleteMyAvailability(input: DeleteMyAvailabilityInput!): DeleteMyAvailabilityPayload
  editMyAvailabilitySchedule(input: EditMyAvailabilityScheduleInput!): EditMyAvailabilitySchedulePayload
  initializeFreeCalendarWeekOverride(input: InitializeFreeCalendarWeekOverrideInput!): InitializeFreeCalendarWeekOverridePayload
  leaveFeedback(input: LeaveFeedbackInput!): LeaveFeedbackPayload
  registerParticipation(input: RegisterParticipationInput!): RegisterParticipationPayload
  cancelBookingAsCoach(input: CancelBookingAsCoachInput!): CancelBookingAsCoachPayload
  addParticipantToBookingAsCoach(input: AddParticipantToBookingAsCoachInput!): AddParticipantToBookingAsCoachPayload
  removeParticipantFromBookingAsCoach(input: RemoveParticipantFromBookingAsCoachInput!): RemoveParticipantFromBookingAsCoachPayload
  addParticipantToMyBooking(input: AddParticipantToMyBookingInput!): AddParticipantToMyBookingPayload
  removeParticipantFromMyBooking(input: RemoveParticipantFromMyBookingInput!): RemoveParticipantFromMyBookingPayload
  bookCoaching(input: BookCoachingInput!): BookCoachingPayload
  cancelBookingAsParticipant(input: CancelBookingAsParticipantInput!): CancelBookingAsParticipantPayload
}

type CoachingOffer implements Node {
  """The ID of an object"""
  id: ID!
  description: CoachingOfferDescription
  setting: CoachingSetting!
  associatedCoaches: [CoachProfile!]!
  licenseAvailability: LicenseAvailability!
  cartClickout: CartClickout
  remunerationData: CoachingOfferRemunerationData!
  visibilityConfigs: [VisibilityCoachingConfig!]!
  participationCertificate: ParticipationCertificate
}

"""A connection to a list of items."""
type CoachingOfferConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CoachingOfferEdge]
}

type CoachingOfferDescription {
  name: String!
  description: String
  shortDescription: String
  modules: String
  contents: String
  image: File
  contractPartner: ContractPartner
  tags: [AcademiesTag!]!
  licenseProduct: LicenseProduct
}

input CoachingOfferDescriptionInput {
  name: String!
  description: String
  shortDescription: String
  modules: String
  contents: String
  imageId: ID
  contractPartnerId: ID
  tagIds: [ID!]!
  licenseProductId: ID
}

"""An edge in a connection."""
type CoachingOfferEdge {
  """The item at the end of the edge."""
  node: CoachingOffer!

  """A cursor for use in pagination."""
  cursor: String!
}

input CoachingOfferParticipationCertificateInput {
  name: String!
  html: String!
  variables: [String!]!
}

interface CoachingOfferRemunerationData {
  kind: CoachingOfferRemunerationDataKind!
  percentageShare: Int!
}

enum CoachingOfferRemunerationDataKind {
  NotRemunerated
  PerSession
}

type CoachingOfferRemunerationDataNotRemunerated implements CoachingOfferRemunerationData {
  kind: CoachingOfferRemunerationDataKind!
  percentageShare: Int!
}

type CoachingOfferRemunerationDataPerSession implements CoachingOfferRemunerationData {
  sessionRate: Price!
  additionalInformation: String
  kind: CoachingOfferRemunerationDataKind!
  percentageShare: Int!
}

type CoachingQueries {
  CoachingOffersToCoach(before: String, after: String, first: Int, last: Int, coachProfileId: ID!): CoachingOfferConnection!
  CoachAvailabilities(before: String, after: String, first: Int, last: Int, onlyNeedConfirmation: Boolean, onlyBooked: Boolean, filterByMinDate: LocalDate, filterByMaxDate: LocalDate, onlyFree: Boolean): AvailabilityConnection!
  FreeAvailabilities(before: String, after: String, first: Int, last: Int, filterByCoach: ID, filterByMinDate: LocalDate, filterByMaxDate: LocalDate): AvailabilityConnection!
}

interface CoachingSetting {
  kind: CoachingSettingKind!
}

enum CoachingSettingKind {
  OneToOne
  Group
}

"""Data partaining to the current user"""
type CoachingViewerSchema {
  MyCoachProfile: CoachProfile
  CoachingOffers(before: String, after: String, first: Int, last: Int): CoachingOfferConnection!
  MyDocuments: [File!]!
  MyAvailabilitySchedule: AvailabilitySchedule
  CoachCoachingAppointments(before: String, after: String, first: Int, last: Int, filterByMinDate: LocalDate, filterByMaxDate: LocalDate): AvailabilityConnection!
  FreeCalendarWeeks: [CalendarWeekAndYear!]!
  MyCoachingAppointments(before: String, after: String, first: Int, last: Int, filterByMinDate: LocalDate, filterByMaxDate: LocalDate): AvailabilityConnection!
}

type CoachProfile implements Node {
  """The ID of an object"""
  id: ID!
  coachAccountId: ID!
  baseData: BaseData!
  averageFeedbackScore: Float!
  feedbacks(before: String, after: String, first: Int, last: Int): CoachFeedbackConnection!
  coach: User
  profileData: ProfileData!
  businessData: BusinessData!
}

input CoachProfileBaseData {
  birthPlace: String!
  nationality: String!
  address: AddressInput!
  birthDate: LocalDate!
  gender: Gender!
}

"""An edge in a connection."""
type CoachProfileEdge {
  """The item at the end of the edge."""
  node: CoachProfile!

  """A cursor for use in pagination."""
  cursor: String!
}

type CoachProfileWithCoachings {
  coachings: [CoachingOffer!]!
  coachingOffer: CoachProfile!
}

"""A connection to a list of items."""
type CoachProfileWithCoachingsConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CoachProfileWithCoachingsEdge]
}

"""An edge in a connection."""
type CoachProfileWithCoachingsEdge {
  """The item at the end of the edge."""
  node: CoachProfileWithCoachings!

  """A cursor for use in pagination."""
  cursor: String!
}

type CoachStatement implements Node {
  """The ID of an object"""
  id: ID!
  coachAccountId: ID!
  createdAt: ZonedDateTIme!
  creditNoteData: CreditNoteData
  billingDetails: BillingDetails
  lineItems: [SessionLineItem!]!
}

"""A connection to a list of items."""
type CoachStatementConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CoachStatementEdge]
}

"""An edge in a connection."""
type CoachStatementEdge {
  """The item at the end of the edge."""
  node: CoachStatement!

  """A cursor for use in pagination."""
  cursor: String!
}

enum CompanyType {
  Einzelunternehmen
  Ag
  Ev
  Kg
  Gbr
  Gmbh
  GmbhCoKg
  OeffentlicheEinrichtung
  Ohg
  Ug
  PartmbH
  Unknown
}

enum CompanyTypeInput {
  Einzelunternehmen
  Ag
  Ev
  Kg
  Gbr
  Gmbh
  GmbhCoKg
  OeffentlicheEinrichtung
  Ohg
  Ug
  PartmbH
  Unknown
}

input ConstellationCreateBranchRootInput {
  title: String!
  clientMutationId: String
}

type ConstellationCreateBranchRootPayload {
  edge: UnpublishedLearnablesEdge!
  clientMutationId: String
}

type ConstellationLoginResultExtension implements LoginResultExtension {
  forwardToFrontendURL: String
  isAVGSClient: Boolean!
  doNotUse: String!
}

type ConstellationRootExtensionExtension implements RootExtensionExtension {
  isMicroLearning: Boolean!
  contractPartner: ContractPartner
  doNotUse: String!
}

interface ContentExtension {
  doNotUse: String!
}

type ContentExtensionImpl implements ContentExtension {
  doNotUse: String!
}

enum ContentKind {
  ELearning
  Async
}

interface ContentNodeAdvancementResult {
  status: ContentNodeAdvancementStatus!
}

enum ContentNodeAdvancementStatus {
  BlockedByTree
  NotContentNode
  ViolatesTreeFlow
  CanBeStarted
  CanNotBeStarted
  Continue
  CanBeRestartedAfterPassed
  CanNotBeRestartedAfterPassed
  CanBeRestartedAfterFailed
  CanNotBeRestartedAfterFailed
}

type ContentSubmission implements Node {
  """The ID of an object"""
  id: ID!
  definition: ContentSubmissionDefinition!
  lastUpdated: ZonedDateTIme
  learnOpportunity: LearnOpportunityV2
  startedAt: ZonedDateTIme!
}

interface ContentSubmissionDefinition {
  status: ContentSubmissionStatus!
  contentKind: ContentKind!
}

"""A connection to a list of items."""
type ContentSubmissionsConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [ContentSubmissionsEdge]
}

"""An edge in a connection."""
type ContentSubmissionsEdge {
  """The item at the end of the edge."""
  node: ContentSubmission!

  """A cursor for use in pagination."""
  cursor: String!
}

enum ContentSubmissionStatus {
  active
  passed
  failed
}

interface ContentTypeDefinition {
  extension: ContentExtension!
  continueConfig: ContinueContentConfig!
  passConfig: PassContentConfig!
  restartIfFailedConfigs: [RestartIfFailedContentConfig!]!
  restartIfPassedConfig: RestartIfPassedContentConfig!
  rewardConfig: RewardContentConfig!
  rewards: [Reward!]!
  startConfigs: [StartContentConfig!]!
  contentKind: ContentKind!
  definitionType: TypeDefinitionType!
}

interface ContinueContentConfig {
  """The ID of an object"""
  id: ID!
  configType: ContinueContentConfigType!
}

enum ContinueContentConfigType {
  ContinueContent_AlwaysRestart
}

type ContinueContentNodeAdvancementResult implements ContentNodeAdvancementResult {
  activeContentSubmissionId: ID!
  status: ContentNodeAdvancementStatus!
}

type ContractPartner implements Node {
  """The ID of an object"""
  id: ID!
  data: ContractPartnerData!
  shareAmountPercentage: Int!
  stripeConnectAccountId: String
}

type ContractPartnerData {
  name: String!
  email: String!
  association: String
  street: String
  houseNumber: String
  city: String
  postalCode: String
  country: String
  taxNumber: String
  linkToAGB: String
}

input ContractPartnerDataInput {
  name: String!
  email: String!
  association: String!
  street: String!
  houseNumber: String!
  city: String!
  postalCode: String!
  country: String!
  taxNumber: String!
  linkToAGB: String
}

"""A connection to a list of items."""
type ContractPartnersConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [ContractPartnersEdge]
}

"""An edge in a connection."""
type ContractPartnersEdge {
  """The item at the end of the edge."""
  node: ContractPartner!

  """A cursor for use in pagination."""
  cursor: String!
}

type CoordinatesV2 {
  parentRef: ID
}

enum CountryCode {
  DE
  CH
  AT
}

input CreateAccountGroupAssignmentRuleInput {
  name: String!
  active: Boolean!
  licenseGroupingId: ID!
  userInAccountGroupIds: [ID!]!
  clientMutationId: String
}

type CreateAccountGroupAssignmentRulePayload {
  assignmentRule: AssignmentRule!
  clientMutationId: String
}

input CreateAccountGroupProductInput {
  title: String!
  clientMutationId: String
}

type CreateAccountGroupProductPayload {
  edge: ProductsEdge!
  clientMutationId: String
}

input CreateAccountInput {
  name: String!
  clientMutationId: String
}

type CreateAccountPayload {
  edge: AccountEdge!
  clientMutationId: String
}

input CreateAndAppendChildTagInput {
  data: TagDataInput!
  parentId: ID!
  clientMutationId: String
}

type CreateAndAppendChildTagPayload {
  edge: AcademiesChildTagsEdge!
  clientMutationId: String
}

input CreateAvailabilityInput {
  coachAccountRef: ID!
  coachRef: ID!
  availabilityData: AvailabilityDataInput!
  clientMutationId: String
}

type CreateAvailabilityPayload {
  edge: AvailabilityEdge!
  clientMutationId: String
}

input CreateAVGSPotentialAnalysisLicenseDefinitionInput {
  data: AVGSPotentialAnalysisLicenseDefinitionDataInput!
  clientMutationId: String
}

type CreateAVGSPotentialAnalysisLicenseDefinitionPayload {
  edge: LicenseDefinitionsEdge!
  clientMutationId: String
}

input CreateBranchChildInput {
  title: String!
  parentBranchId: ID!
  clientMutationId: String
}

type CreateBranchChildPayload {
  createdChildNode: TreeNode!
  tree: Tree!
  clientMutationId: String
}

input CreateBranchRootInput {
  title: String!
  clientMutationId: String
}

type CreateBranchRootPayload {
  createdRootNode: TreeNodesEdge!
  tree: Tree!
  clientMutationId: String
}

input CreateClickOutByLinkIdInput {
  linkId: String!
  clientMutationId: String
}

type CreateClickOutByLinkIdPayload {
  placementUrl: String!
  clientMutationId: String
}

input CreateClickOutForUserOrBusinessInput {
  clientMutationId: String
}

type CreateClickOutForUserOrBusinessPayload {
  placementUrl: String!
  clientMutationId: String
}

input CreateClozeTextElementV2Input {
  title: String!
  text: String!
  additionalWords: [String!]!
  eLearningContentNodeId: ID!
  clientMutationId: String
}

type CreateClozeTextElementV2Payload {
  eLearningContentNode: TreeNode!
  clientMutationId: String
}

input CreateCoachingLicenseDefinitionInput {
  data: CoachingLicenseDefinitionDataInput!
  clientMutationId: String
}

type CreateCoachingLicenseDefinitionPayload {
  edge: LicenseDefinitionsEdge!
  clientMutationId: String
}

input CreateCoachingOfferInput {
  kind: CoachingSettingKind!
  clientMutationId: String
}

type CreateCoachingOfferPayload {
  edge: UnpublishedLearnablesEdge!
  clientMutationId: String
}

input CreateCoachProfileInput {
  accountId: ID!
  userId: ID!
  baseData: CoachProfileBaseData!
  clientMutationId: String
}

type CreateCoachProfilePayload {
  edge: CoachProfileEdge!
  clientMutationId: String
}

input CreateCoachStatementsFromUnbilledInput {
  clientMutationId: String
}

type CreateCoachStatementsFromUnbilledPayload {
  clientMutationId: String
}

input CreateContentChildInput {
  title: String!
  parentBranchId: ID!
  contentKind: String!
  clientMutationId: String
}

type CreateContentChildPayload {
  createdChildNode: TreeNode!
  tree: Tree!
  clientMutationId: String
}

input CreateContentRootNodeInput {
  title: String!
  contentKind: String!
  clientMutationId: String
}

type CreateContentRootNodePayload {
  createdRootNode: TreeNodesEdge!
  tree: Tree!
  clientMutationId: String
}

input CreateContractPartnerInput {
  shareAmountPercentage: Int!
  data: ContractPartnerDataInput!
  clientMutationId: String
}

type CreateContractPartnerPayload {
  edge: ContractPartnersEdge!
  clientMutationId: String
}

input CreateCustomerFeedbackInput {
  name: String!
  position: String!
  feedback: String!
  clientMutationId: String
}

type CreateCustomerFeedbackPayload {
  edge: CustomerFeedbackEdge!
  clientMutationId: String
}

input CreateDiscountCodeInput {
  code: String!
  discountActionId: ID!
  clientMutationId: String
}

type CreateDiscountCodePayload {
  edges: [DiscountCodesV2Edge!]!
  clientMutationId: String
}

input CreateDynamicVocabElementInput {
  title: String!
  eLearningContentNodeId: ID!
  clientMutationId: String
}

type CreateDynamicVocabElementPayload {
  eLearningContentNode: TreeNode!
  clientMutationId: String
}

input CreateEnhancedTextElementInput {
  title: String!
  text: String!
  readMore: String
  readMoreButtonText: String
  eLearningContentNodeId: ID!
  clientMutationId: String
}

type CreateEnhancedTextElementPayload {
  eLearningContentNode: TreeNode!
  clientMutationId: String
}

input CreateEuroDiscountActionInput {
  title: String!
  clientMutationId: String
}

type CreateEuroDiscountActionPayload {
  edge: DiscountActionsEdge!
  clientMutationId: String
}

input CreateExternalLicenseInput {
  data: ExternalLicenseDataInput!
  poolId: ID!
  clientMutationId: String
}

type CreateExternalLicensePayload {
  edge: ExternalLicensesEdge!
  clientMutationId: String
}

input CreateExternalLicensePoolInput {
  data: ExternalLicensePoolDataInput!
  clientMutationId: String
}

type CreateExternalLicensePoolPayload {
  edge: ExternalLicensePoolsEdge!
  clientMutationId: String
}

input CreateFileElementV2Input {
  title: String!
  eLearningContentNodeId: ID!
  fileId: ID
  clientMutationId: String
}

type CreateFileElementV2Payload {
  eLearningContentNode: TreeNode!
  clientMutationId: String
}

input CreateGlobalVocabElementInput {
  title: String!
  eLearningContentNodeId: ID!
  clientMutationId: String
}

type CreateGlobalVocabElementPayload {
  eLearningContentNode: TreeNode!
  clientMutationId: String
}

input CreateInstructorImplInput {
  data: InstructorImplInput!
  clientMutationId: String
}

type CreateInstructorImplPayload {
  data: InstructorImplsEdge!
  clientMutationId: String
}

input CreateLicenseProductInput {
  title: String!
  clientMutationId: String
}

type CreateLicenseProductPayload {
  edge: ProductsEdge!
  clientMutationId: String
}

input CreateLicensesInput {
  amount: Int!
  licenseDefinitionId: ID!
  accountId: ID!
  clientMutationId: String
}

type CreateLicensesPayload {
  edges: [LicenseEdge!]!
  clientMutationId: String
}

input CreateLimitedCartDiscountInput {
  clientMutationId: String
}

type CreateLimitedCartDiscountPayload {
  edge: LimitedCartDiscountEdge!
  clientMutationId: String
}

input CreateMarkMistakesElementInput {
  title: String!
  text: String!
  eLearningContentId: ID!
  clientMutationId: String
}

type CreateMarkMistakesElementPayload {
  eLearningContent: TreeNode!
  clientMutationId: String
}

input CreateMatrixElementInput {
  title: String!
  firstRowTitle: String!
  firstColumnTitle: String!
  correctAnswer: String!
  eLearningContentId: ID!
  clientMutationId: String
}

type CreateMatrixElementPayload {
  eLearningContent: TreeNode!
  clientMutationId: String
}

input CreateMicroLearningLicenseDefinitionInput {
  data: MicroLearningLicenseDefinitionDataInput!
  clientMutationId: String
}

type CreateMicroLearningLicenseDefinitionPayload {
  edge: LicenseDefinitionsEdge!
  clientMutationId: String
}

input CreateMultipleChoiceElementV2Input {
  title: String!
  question: String!
  answeringType: String!
  answeringTypeText: String
  answerOptions: [AnswerOptionV2Input!]!
  eLearningContentNodeId: ID!
  imageId: ID
  clientMutationId: String
}

type CreateMultipleChoiceElementV2Payload {
  eLearningContentNode: TreeNode!
  clientMutationId: String
}

input CreateMyAvailabilityInput {
  availabilityData: AvailabilityDataInput!
  clientMutationId: String
}

type CreateMyAvailabilityPayload {
  edge: AvailabilityEdge!
  clientMutationId: String
}

input CreateOrderElementInput {
  title: String!
  eLearningContentNodeId: ID!
  clientMutationId: String
}

type CreateOrderElementPayload {
  eLearningContentNode: TreeNode!
  clientMutationId: String
}

input CreateOrderInput {
  cartSelection: CartSelectionInput
  clientMutationId: String
}

type CreateOrderPayload {
  order: Order!
  clientMutationId: String
}

input CreatePercentageDiscountActionInput {
  title: String!
  clientMutationId: String
}

type CreatePercentageDiscountActionPayload {
  edge: DiscountActionsEdge!
  clientMutationId: String
}

input CreatePersonalizedEmailTemplateInput {
  data: PersonalizedEmailTemplateInput!
  clientMutationId: String
}

type CreatePersonalizedEmailTemplatePayload {
  data: PersonalizedEmailTemplatesEdge!
  clientMutationId: String
}

input CreatePersonalizedNotificationTemplateInput {
  data: PersonalizedNotificationTemplateInput!
  clientMutationId: String
}

type CreatePersonalizedNotificationTemplatePayload {
  data: PersonalizedNotificationTemplatesEdge!
  clientMutationId: String
}

input CreatePlacementProductInput {
  title: String!
  clientMutationId: String
}

type CreatePlacementProductPayload {
  edge: ProductsEdge!
  clientMutationId: String
}

input CreatePodcastElementV2Input {
  title: String!
  eLearningContentNodeId: ID!
  clientMutationId: String
}

type CreatePodcastElementV2Payload {
  eLearningContentNode: TreeNode!
  clientMutationId: String
}

input CreatePodcastWithTimestampInput {
  title: String!
  eLearningContentId: ID!
  podcastFileId: ID
  timestampsWithImage: [TimestampWithImageInput!]!
  clientMutationId: String
}

type CreatePodcastWithTimestampPayload {
  eLearningContent: TreeNode!
  clientMutationId: String
}

input CreatePotentialAnalysisClickoutInput {
  shortTest: Boolean!
  clientMutationId: String
}

type CreatePotentialAnalysisClickoutPayload {
  clickout: String!
  clientMutationId: String
}

input CreatePotentialAnalysisInput {
  clientEmail: String!
  coachAccountId: ID!
  coachId: ID!
  replacementCoachId: ID
  selectedModuleIds: [Int!]!
  clientMutationId: String
}

type CreatePotentialAnalysisPayload {
  edge: PotentialAnalysisEdge!
  info: AVGSPotentialAnalysis_Info!
  clientMutationId: String
}

input CreateRandomDiscountCodesInput {
  number: Int!
  discountActionId: ID!
  clientMutationId: String
}

type CreateRandomDiscountCodesPayload {
  edges: [DiscountCodesV2Edge!]!
  clientMutationId: String
}

input CreateReportInput {
  data: DSAReportDataInput!
  clientMutationId: String
}

type CreateReportPayload {
  referenceNumber: String!
  clientMutationId: String
}

input CreateRootTagInput {
  data: TagDataInput!
  clientMutationId: String
}

type CreateRootTagPayload {
  edge: AcademiesRootTagsEdge!
  clientMutationId: String
}

input CreateSingleUserAssignmentRuleInput {
  maxLicenseAmount: Int!
  licenseGroupingId: ID!
  userId: ID!
  clientMutationId: String
}

type CreateSingleUserAssignmentRulePayload {
  assignmentRule: AssignmentRule!
  clientMutationId: String
}

input CreateStripeConnectAccountInput {
  contractPartnerId: ID!
  clientMutationId: String
}

type CreateStripeConnectAccountPayload {
  contractPartner: ContractPartnersEdge!
  clientMutationId: String
}

input CreateTagInput {
  data: TagInput!
  clientMutationId: String
}

type CreateTagPayload {
  data: TagsEdge!
  clientMutationId: String
}

input CreateTextElementV2Input {
  title: String!
  text: String!
  eLearningContentNodeId: ID!
  clientMutationId: String
}

type CreateTextElementV2Payload {
  eLearningContentNode: TreeNode!
  clientMutationId: String
}

input CreateTreeLicenseDefinitionInput {
  data: TreeLicenseDefinitionDataInput!
  clientMutationId: String
}

type CreateTreeLicenseDefinitionPayload {
  edge: LicenseDefinitionsEdge!
  clientMutationId: String
}

input CreateTrendInput {
  trendData: TrendDataInput!
  trendMedia: TrendMediaInput!
  customerData: CustomerDataInput!
  coachingImageId: ID!
  potentialAnalysisHeadingAndDescription: HeadingAndDescriptionInput!
  coachingHeadingAndDescription: HeadingAndDescriptionInput!
  aboutOffersHeadingAndDescription: HeadingAndDescriptionInput!
  clientMutationId: String
}

type CreateTrendPayload {
  edge: TrendEdge!
  clientMutationId: String
}

input CreateUploadAsyncElementInput {
  title: String!
  asyncContentId: ID!
  clientMutationId: String
}

type CreateUploadAsyncElementPayload {
  asyncContent: TreeNode!
  clientMutationId: String
}

input CreateUserInAccountGroupAndAddOrInviteUsersMutationInput {
  name: String!
  emails: [String!]!
  clientMutationId: String
}

type CreateUserInAccountGroupAndAddOrInviteUsersMutationPayload {
  newGroup: UserInAccountGroupWrapperEdge!
  clientMutationId: String
}

input CreateUserInAccountInput {
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  adsOptIn: Boolean!
  accountId: ID!
  clientMutationId: String
}

type CreateUserInAccountPayload {
  userInAccount: UserInAccountEdge!
  clientMutationId: String
}

input CreateVideoElementV2Input {
  title: String!
  vimeoId: String!
  eLearningContentNodeId: ID!
  clientMutationId: String
}

type CreateVideoElementV2Payload {
  eLearningContentNode: TreeNode!
  clientMutationId: String
}

input CreateWordPackageInput {
  data: WordPackageDataInput!
  clientMutationId: String
}

type CreateWordPackagePayload {
  edge: WordPackageEdge!
  clientMutationId: String
}

type CreditNoteData {
  creditNoteId: String!
  creditNoteNumber: String
  creditNoteFile: File
}

type CreditNoteSentUpdate implements HistoryEventInterface {
  creditNoteId: String!
  creditNoteNumber: String!
  kind: HistoryEventType!
}

type CrmTreeHeadUpdater_ErrorOccurredRewardResult implements RewardResult {
  rewardId: ID!
  rewardKind: RewardKind!
  kind: RewardResultKind!
}

type CrmTreeHeadUpdater_HeadUpdatedRewardResult implements RewardResult {
  rewardId: ID!
  rewardKind: RewardKind!
  kind: RewardResultKind!
}

type CrmTreeHeadUpdater_NotPassedRewardResult implements RewardResult {
  rewardId: ID!
  rewardKind: RewardKind!
  kind: RewardResultKind!
}

type CrmTreeHeadUpdaterReward implements Reward {
  """The ID of an object"""
  id: ID!
  superId: ID!
  kind: RewardKind!
}

type CurrentUser {
  user: User!
  accounts: [Account!]!
  permissionsInAccount: [Permission!]!
}

type CustomerData {
  customerFeedbacks: [CustomerFeedback!]!
  amountCustomer: String!
}

input CustomerDataInput {
  customerFeedbackIds: [ID!]!
  amountCustomer: String!
}

type CustomerFeedback implements Node {
  """The ID of an object"""
  id: ID!
  name: String!
  position: String!
  feedback: String!
}

"""Data only accessible by the admin"""
type CustomerFeedbackAdminMutationSchema {
  createCustomerFeedback(input: CreateCustomerFeedbackInput!): CreateCustomerFeedbackPayload
  editCustomerFeedback(input: EditCustomerFeedbackInput!): EditCustomerFeedbackPayload
  deleteCustomerFeedback(input: DeleteCustomerFeedbackInput!): DeleteCustomerFeedbackPayload
}

"""A connection to a list of items."""
type CustomerFeedbackConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CustomerFeedbackEdge]
}

"""An edge in a connection."""
type CustomerFeedbackEdge {
  """The item at the end of the edge."""
  node: CustomerFeedback!

  """A cursor for use in pagination."""
  cursor: String!
}

type CustomerJourneyQueries {
  CustomerFeedback(before: String, after: String, first: Int, last: Int): CustomerFeedbackConnection!
  trend(before: String, after: String, first: Int, last: Int): TrendConnection!
  Dashboard(before: String, after: String, first: Int, last: Int, filterByText: String, kinds: [LearnableKind!]!, filterByCompleted: Boolean!): Dashboard
}

enum CustomerType {
  Private
  Business
}

type Dashboard {
  userData: User
  sortedLearnables(before: String, after: String, first: Int, last: Int): SortedLearnablesConnection!
  mostRecentLearnable: LearnableWithLastUpdated
}

type DayAndTimesForCalendarWeek {
  timeSlots: [LocalTime!]!
  dayOfWeek: DayOfWeek!
  calendarWeek: Int!
  calendarYear: Int!
}

input DayAndTimesForCalendarWeekInput {
  timeSlots: [LocalTime!]!
  dayOfWeek: DayOfWeek!
  calendarWeek: Int!
  calendarYear: Int!
}

input DayAndTimesInput {
  timeSlots: [LocalTime!]!
  dayOfWeek: DayOfWeek!
}

scalar DayOfWeek

type DefaultFileAttachment implements FileAttachment & AttachmentV2 {
  file: File

  """The ID of an object"""
  id: ID!
  title: String
  description: String
  kind: AttachmentKind!
}

type DefaultPaymentProviderData implements PaymentProviderData {
  paymentMethod: PaymentMethodType!
  dataType: PaymentProviderDataType!
}

input DeleteAssignmentRuleInput {
  assignmentRuleId: ID!
  clientMutationId: String
}

type DeleteAssignmentRulePayload {
  clientMutationId: String
}

input DeleteAvailabilityInput {
  ids: [ID!]!
  clientMutationId: String
}

type DeleteAvailabilityPayload {
  deletedIds: [ID!]!
  clientMutationId: String
}

input DeleteCoachingOfferInput {
  coachingId: ID!
  clientMutationId: String
}

type DeleteCoachingOfferPayload {
  deletedUnpublishedLearnableId: ID!
  clientMutationId: String
}

input DeleteCoachProfileInput {
  ids: [ID!]!
  clientMutationId: String
}

type DeleteCoachProfilePayload {
  deletedIds: [ID!]!
  clientMutationId: String
}

input DeleteConditionInput {
  limitedCartDiscountId: ID!
  conditionId: ID!
  clientMutationId: String
}

type DeleteConditionPayload {
  limitedCartDiscount: LimitedCartDiscount!
  clientMutationId: String
}

input DeleteContractPartnerInput {
  ids: [ID!]!
  clientMutationId: String
}

type DeleteContractPartnerPayload {
  deletedIds: [ID!]!
  clientMutationId: String
}

input DeleteCourseOrMicroLearningLearnableInput {
  rootId: ID!
  clientMutationId: String
}

type DeleteCourseOrMicroLearningLearnablePayload {
  deletedCourseOrMicroLearningLearnableId: ID!
  clientMutationId: String
}

input DeleteCustomerFeedbackInput {
  ids: [ID!]!
  clientMutationId: String
}

type DeleteCustomerFeedbackPayload {
  deletedIds: [ID!]!
  clientMutationId: String
}

input DeleteDiscountActionInput {
  ids: [ID!]!
  clientMutationId: String
}

type DeleteDiscountActionPayload {
  deletedIds: [ID!]!
  clientMutationId: String
}

input DeleteDiscountCodeInput {
  ids: [ID!]!
  clientMutationId: String
}

type DeleteDiscountCodePayload {
  deletedIds: [ID!]!
  clientMutationId: String
}

input DeleteElementV2Input {
  elementId: ID!
  clientMutationId: String
}

type DeleteElementV2Payload {
  eLearningContentNode: TreeNode!
  clientMutationId: String
}

input DeleteExternalLicenseInput {
  ids: [ID!]!
  clientMutationId: String
}

type DeleteExternalLicensePayload {
  deletedIds: [ID!]!
  clientMutationId: String
}

input DeleteExternalLicensePoolInput {
  id: ID!
  clientMutationId: String
}

type DeleteExternalLicensePoolPayload {
  """The ID of an object"""
  id: ID!
  clientMutationId: String
}

input DeleteFileInput {
  ids: [ID!]!
  clientMutationId: String
}

type DeleteFilePayload {
  deletedIds: [ID!]!
  clientMutationId: String
}

input DeleteInstructorImplInput {
  ids: [ID!]!
  clientMutationId: String
}

type DeleteInstructorImplPayload {
  deletedIds: [ID!]!
  clientMutationId: String
}

input DeleteInvitationInput {
  id: ID!
  clientMutationId: String
}

type DeleteInvitationPayload {
  deletedId: ID
  clientMutationId: String
}

input DeleteLicenseDefinitionInput {
  licenseDefinitionId: ID!
  clientMutationId: String
}

type DeleteLicenseDefinitionPayload {
  deletedIds: [ID!]!
  clientMutationId: String
}

input DeleteLicenseInput {
  ids: [ID!]!
  clientMutationId: String
}

type DeleteLicensePayload {
  deletedIds: [ID!]!
  clientMutationId: String
}

input DeleteLimitedCartDiscountInput {
  ids: [ID!]!
  clientMutationId: String
}

type DeleteLimitedCartDiscountPayload {
  deletedIds: [ID!]!
  clientMutationId: String
}

input DeleteMyAvailabilityInput {
  ids: [ID!]!
  clientMutationId: String
}

type DeleteMyAvailabilityPayload {
  deletedIds: [ID!]!
  clientMutationId: String
}

input DeletePersonalizedEmailTemplateInput {
  ids: [ID!]!
  clientMutationId: String
}

type DeletePersonalizedEmailTemplatePayload {
  deletedIds: [ID!]!
  clientMutationId: String
}

input DeletePersonalizedNotificationTemplateInput {
  ids: [ID!]!
  clientMutationId: String
}

type DeletePersonalizedNotificationTemplatePayload {
  deletedIds: [ID!]!
  clientMutationId: String
}

input DeleteProductInput {
  ids: [ID!]!
  clientMutationId: String
}

type DeleteProductPayload {
  deletedIds: [ID!]!
  clientMutationId: String
}

input DeleteRewardInput {
  contentNodeId: ID!
  rewardId: ID!
  clientMutationId: String
}

type DeleteRewardPayload {
  contentNode: TreeNode!
  clientMutationId: String
}

input deleteTagInput {
  id: ID!
  clientMutationId: String
}

input DeleteTagInput {
  ids: [ID!]!
  clientMutationId: String
}

type deleteTagPayload {
  deletedId: ID!
  clientMutationId: String
}

type DeleteTagPayload {
  deletedIds: [ID!]!
  clientMutationId: String
}

input DeleteTreeInput {
  rootId: ID!
  clientMutationId: String
}

type DeleteTreePayload {
  deletedRootId: ID!
  clientMutationId: String
}

input DeleteTrendInput {
  ids: [ID!]!
  clientMutationId: String
}

type DeleteTrendPayload {
  deletedIds: [ID!]!
  clientMutationId: String
}

input DeleteUserInAccountGroupsInput {
  ids: [ID!]!
  clientMutationId: String
}

type DeleteUserInAccountGroupsPayload {
  removedIds: [ID!]!
  clientMutationId: String
}

input DeleteUserInput {
  userId: ID!
  clientMutationId: String
}

type DeleteUserPayload {
  deletedIds: [ID!]!
  clientMutationId: String
}

input DeleteWordInput {
  wordPackageId: ID!
  wordId: ID!
  clientMutationId: String
}

input DeleteWordPackageInput {
  ids: [ID!]!
  clientMutationId: String
}

type DeleteWordPackagePayload {
  deletedIds: [ID!]!
  clientMutationId: String
}

type DeleteWordPayload {
  wordPackage: WordPackage!
  clientMutationId: String
}

type DirectFeedbackFlowELearningContentConfig implements FlowELearningContentConfig {
  minNumTriesTillShowAnswer: Int!

  """The ID of an object"""
  id: ID!
  configType: FlowELearningContentConfigType!
}

"""a discount action is a common wrapper of 0 - n discount codes."""
type DiscountAction implements Node {
  """The ID of an object"""
  id: ID!
  calcType: DiscountActionCalcType!
  createdAt: ZonedDateTIme!
  discountCodes(before: String, after: String, first: Int, last: Int): DiscountCodesV2Connection!
  discountCodesCSV: String!
  discountType: DiscountType!
  numUsages: Int!
  title: String!
  usageLimitation: DiscountActionUsageLimitation!
  validUntil: DiscountActionValidUntil!
}

interface DiscountActionAmountLimitation {
  kind: DiscountActionAmountLimitationKind!
}

enum DiscountActionAmountLimitationKind {
  limited
  unlimited
}

type DiscountActionAmountLimited implements DiscountActionAmountLimitation {
  max: Int!
  kind: DiscountActionAmountLimitationKind!
}

type DiscountActionAmountUnlimited implements DiscountActionAmountLimitation {
  kind: DiscountActionAmountLimitationKind!
}

interface DiscountActionCalcType {
  kind: DiscountActionCalcTypeKind!
}

enum DiscountActionCalcTypeKind {
  percentage
  euro
}

type DiscountActionEuroCalcType implements DiscountActionCalcType {
  euro: BigDecimal!
  kind: DiscountActionCalcTypeKind!
}

type DiscountActionPercentageCalcType implements DiscountActionCalcType {
  percentage: BigDecimal!
  kind: DiscountActionCalcTypeKind!
}

"""A connection to a list of items."""
type DiscountActionsConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [DiscountActionsEdge]
}

"""An edge in a connection."""
type DiscountActionsEdge {
  """The item at the end of the edge."""
  node: DiscountAction!

  """A cursor for use in pagination."""
  cursor: String!
}

interface DiscountActionUsageLimitation {
  kind: DiscountActionUsageLimitationKind!
}

enum DiscountActionUsageLimitationKind {
  limited
  unlimited
}

type DiscountActionUsageLimited implements DiscountActionUsageLimitation {
  onlyForAccountIds: [ID!]!
  onlyForProductIds: [ID!]!
  maxAmountOfUsages: DiscountActionAmountLimitation!
  maxAmountOfUsagesPerAccount: DiscountActionAmountLimitation!
  kind: DiscountActionUsageLimitationKind!
}

type DiscountActionUsageUnlimited implements DiscountActionUsageLimitation {
  kind: DiscountActionUsageLimitationKind!
}

interface DiscountActionValidUntil {
  kind: DiscountActionValidUntilKind!
}

type DiscountActionValidUntilDateTime implements DiscountActionValidUntil {
  dateTime: ZonedDateTIme!
  kind: DiscountActionValidUntilKind!
}

type DiscountActionValidUntilForever implements DiscountActionValidUntil {
  kind: DiscountActionValidUntilKind!
}

enum DiscountActionValidUntilKind {
  untilForever
  untilDateTime
}

"""a discount code."""
type DiscountCode implements Node {
  """The ID of an object"""
  id: ID!
  code: String!
  createdAt: ZonedDateTIme!
  numUsages: Int!
  searchUsages(before: String, after: String, first: Int, last: Int, filterByUsedAtFrom: ZonedDateTIme, filterByUsedToFrom: ZonedDateTIme): SearchDiscountCodeUsagesResult!
}

"""A connection to a list of items."""
type DiscountCodesV2Connection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [DiscountCodesV2Edge]
}

"""An edge in a connection."""
type DiscountCodesV2Edge {
  """The item at the end of the edge."""
  node: DiscountCode!

  """A cursor for use in pagination."""
  cursor: String!
}

type DiscountCodeUsage implements Node {
  """The ID of an object"""
  id: ID!
  order: Order
  at: ZonedDateTIme!
}

"""A connection to a list of items."""
type DiscountCodeUsagesConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [DiscountCodeUsagesEdge]
}

"""An edge in a connection."""
type DiscountCodeUsagesEdge {
  """The item at the end of the edge."""
  node: DiscountCodeUsage!

  """A cursor for use in pagination."""
  cursor: String!
}

interface DiscountType {
  kind: DiscountTypeKind!
}

enum DiscountTypeKind {
  system
  user
}

enum DiscountTypeKindInput {
  system
  user
}

type DisplayMatrixElementCell implements MatrixElementCell {
  content: String!

  """The ID of an object"""
  id: ID!
  xIdx: Int!
  yIdx: Int!
  kind: MatrixElementCellKind!
}

type DisplayMatrixLearnElementCell implements MatrixLearnElementCell {
  content: String!
  xIdx: Int!
  yIdx: Int!
  kind: MatrixElementCellKind!
}

type DoNotRewardTreeConfig implements RewardTreeConfig {
  """The ID of an object"""
  id: ID!
  configType: RewardTreeConfigType!
}

type DoNotShowAnswerTreeConfig implements ShowAnswerTreeConfig {
  """The ID of an object"""
  id: ID!
  configType: ShowAnswerTreeConfigType!
}

type DoRewardContentConfig implements RewardContentConfig {
  """The ID of an object"""
  id: ID!
  configType: RewardContentConfigType!
}

type DSAReport implements Node {
  """The ID of an object"""
  id: ID!
  data: DSAReportData!
  referenceNumber: String!
  createdAt: ZonedDateTIme!
}

"""A connection to a list of items."""
type DSAReportConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [DSAReportEdge]
}

type DSAReportData {
  firstName: String
  lastName: String
  email: String
  reportType: DSAReportType!
  url: String
  problemType: DSAReportProblemType!
  extra: String
}

input DSAReportDataInput {
  firstName: String
  lastName: String
  email: String
  reportType: DSAReportType!
  url: String
  problemType: DSAReportProblemType!
  extra: String
}

"""An edge in a connection."""
type DSAReportEdge {
  """The item at the end of the edge."""
  node: DSAReport!

  """A cursor for use in pagination."""
  cursor: String!
}

enum DSAReportProblemType {
  IllegalContents
  Disinformation
  TransparencyForOnlineAds
  UserRightsAndComplaints
  ProtectionOfMinors
  Accessibility
  PrivacyRequest
  ConsumerProtection
  Other
}

enum DSAReportType {
  Feedback
  Report
  Complaint
  Other
}

type DynamicVocabElement implements ElementV2 {
  numWords: DynamicVocabElementNumWords!
  packageSelections: [VocabTrainWordPackageSelection!]!
  numDecoy: Int!

  """The ID of an object"""
  id: ID!
  title: String!
  elementType: ElementTypeV2!
  extension: ElementExtension!
}

interface DynamicVocabElementNumWords {
  kind: DynamicVocabElementNumWordsKind!
}

type DynamicVocabElementNumWordsAll implements DynamicVocabElementNumWords {
  kind: DynamicVocabElementNumWordsKind!
}

enum DynamicVocabElementNumWordsKind {
  All
  Num
}

input EditAccountGroupAssignmentRuleInput {
  name: String!
  active: Boolean!
  assignmentRuleId: ID!
  userInAccountGroupIds: [ID!]!
  clientMutationId: String
}

type EditAccountGroupAssignmentRulePayload {
  assignmentRule: AssignmentRule!
  clientMutationId: String
}

input EditAccountGroupProductInput {
  title: String!
  isHidden: Boolean!
  isTaxFree: Boolean!
  costUnit: String
  id: ID!
  netPrice: BigDecimal!
  accountGroupId: ID!
  clientMutationId: String
}

type EditAccountGroupProductPayload {
  product: AccountGroupProduct!
  clientMutationId: String
}

input EditAfterDateTimeVisibilityTreeConfigInput {
  newDateTime: ZonedDateTIme!
  rootNodeId: ID!
  configId: ID!
  clientMutationId: String
}

type EditAfterDateTimeVisibilityTreeConfigPayload {
  rootNode: TreeNode!
  clientMutationId: String
}

input EditAssociatedCoachesInput {
  potentialCancellationMessage: String!
  id: ID!
  coachIds: [ID!]!
  clientMutationId: String
}

type EditAssociatedCoachesPayload {
  coachingOffer: CoachingOffer!
  clientMutationId: String
}

input EditAvailabilityInput {
  availabilityId: ID!
  availabilityData: AvailabilityDataInput!
  clientMutationId: String
}

type EditAvailabilityPayload {
  availability: Availability!
  clientMutationId: String
}

input EditAvailabilityScheduleInput {
  coachAccountId: ID!
  coachId: ID!
  scheduleData: ScheduleDataInput!
  clientMutationId: String
}

type EditAvailabilitySchedulePayload {
  schedule: AvailabilitySchedule!
  clientMutationId: String
}

input EditAVGSPotentialAnalysisLicenseDefinitionAdminMutationInput {
  licenseDefinitionId: ID!
  data: AVGSPotentialAnalysisLicenseDefinitionDataInput!
  clientMutationId: String
}

type EditAVGSPotentialAnalysisLicenseDefinitionAdminMutationPayload {
  licenseDefinition: LicenseDefinition!
  clientMutationId: String
}

input EditBaseDataInput {
  coachProfileId: ID!
  baseData: CoachProfileBaseData!
  clientMutationId: String
}

type EditBaseDataPayload {
  edge: CoachProfileEdge!
  clientMutationId: String
}

input EditBlockPermanentlyRestartIfFailedContentConfigInput {
  newMaximumTries: Int!
  contentNodeId: ID!
  configId: ID!
  clientMutationId: String
}

type EditBlockPermanentlyRestartIfFailedContentConfigPayload {
  contentNode: TreeNode!
  clientMutationId: String
}

input EditBlockTemporarilyRestartIfFailedContentConfigInput {
  newDaysToBlock: Int!
  contentNodeId: ID!
  configId: ID!
  clientMutationId: String
}

type EditBlockTemporarilyRestartIfFailedContentConfigPayload {
  contentNode: TreeNode!
  clientMutationId: String
}

input EditBusinessBaseDataAdminInput {
  accountId: ID!
  baseData: BusinessBaseDataInput!
  clientMutationId: String
}

type EditBusinessBaseDataAdminPayload {
  baseData: BusinessBaseData!
  clientMutationId: String
}

input EditBusinessBaseDataInput {
  baseData: BusinessBaseDataInput!
  clientMutationId: String
}

type EditBusinessBaseDataPayload {
  baseData: BusinessBaseData!
  clientMutationId: String
}

input EditBusinessDataInput {
  coachProfileId: ID!
  businessData: BusinessDataInput!
  clientMutationId: String
}

type EditBusinessDataPayload {
  edge: CoachProfileEdge!
  clientMutationId: String
}

input EditClozeTextElementV2Input {
  title: String!
  text: String!
  additionalWords: [String!]!
  clozeTextElementId: ID!
  clientMutationId: String
}

type EditClozeTextElementV2Payload {
  eLearningContentNode: TreeNode!
  clozeTextElement: ClozeTextElementV2!
  clientMutationId: String
}

input EditCoachingLicenseDefinitionAdminMutationInput {
  licenseDefinitionId: ID!
  data: CoachingLicenseDefinitionDataInput!
  clientMutationId: String
}

type EditCoachingLicenseDefinitionAdminMutationPayload {
  licenseDefinition: LicenseDefinition!
  clientMutationId: String
}

input EditCoachingOfferParticipationCertificateInput {
  coachingOfferId: ID!
  participationCertificateOpt: CoachingOfferParticipationCertificateInput
  clientMutationId: String
}

type EditCoachingOfferParticipationCertificatePayload {
  coachingOffer: CoachingOffer!
  clientMutationId: String
}

input EditContractPartnerDataInput {
  shareAmountPercentage: Int!
  id: ID!
  data: ContractPartnerDataInput!
  clientMutationId: String
}

type EditContractPartnerDataPayload {
  contractPartner: ContractPartner!
  clientMutationId: String
}

input EditCustomerFeedbackInput {
  name: String!
  position: String!
  feedback: String!
  customerFeedbackId: ID!
  clientMutationId: String
}

type EditCustomerFeedbackPayload {
  edge: CustomerFeedbackEdge!
  clientMutationId: String
}

input EditDefaultFileAttachmentInput {
  titleOpt: String
  descriptionOpt: String
  nodeId: ID!
  attachmentId: ID!
  fileId: ID!
  clientMutationId: String
}

type EditDefaultFileAttachmentPayload {
  node: TreeNode!
  clientMutationId: String
}

input EditDirectFeedbackFlowELearningContentConfigInput {
  minNumTriesTillShowAnswer: Int!
  contentId: ID!
  configId: ID!
  clientMutationId: String
}

type EditDirectFeedbackFlowELearningContentConfigPayload {
  content: TreeNode!
  clientMutationId: String
}

input EditDiscountCodeInput {
  newCode: String!
  discountCodeId: ID!
  clientMutationId: String
}

type EditDiscountCodePayload {
  discountCode: DiscountCode!
  clientMutationId: String
}

input EditDynamicVocabElementInput {
  title: String!
  elementId: ID!
  wordPackageIds: [ID!]!
  clientMutationId: String
}

type EditDynamicVocabElementPayload {
  eLearningContentNode: TreeNode!
  dynamicVocabElement: DynamicVocabElement!
  clientMutationId: String
}

input EditEducationalParticipationCertificateRewardInput {
  contentId: ID!
  rewardId: ID!
  newData: ParticipationCertificateRewardDataInput!
  clientMutationId: String
}

type EditEducationalParticipationCertificateRewardPayload {
  content: TreeNode!
  clientMutationId: String
}

input EditEnhancedTextElementInput {
  title: String!
  text: String!
  readMore: String
  readMoreButtonText: String
  enhancedTextElementId: ID!
  clientMutationId: String
}

type EditEnhancedTextElementPayload {
  eLearningContentNode: TreeNode!
  enhancedTextElement: EnhancedTextElement!
  clientMutationId: String
}

input EditEuroDiscountActionInput {
  newTitle: String!
  newDiscountType: String!
  newEuro: BigDecimal!
  newUsageLimitation: UpdateUsageLimited
  newValidUntil: ZonedDateTIme
  discountActionId: ID!
  clientMutationId: String
}

type EditEuroDiscountActionPayload {
  discountAction: DiscountAction!
  clientMutationId: String
}

input EditExternalLicenseInput {
  data: ExternalLicenseDataInput!
  externalLicenseId: ID!
  clientMutationId: String
}

type EditExternalLicensePayload {
  externalLicense: ExternalLicense!
  clientMutationId: String
}

input EditExternalLicensePoolInput {
  data: ExternalLicensePoolDataInput!
  id: ID!
  clientMutationId: String
}

type EditExternalLicensePoolPayload {
  externalLicensePool: ExternalLicensePool!
  clientMutationId: String
}

input EditExternalLicenseRewardInput {
  newData: ExternalLicenseRewardDataInput!
  contentId: ID!
  rewardId: ID!
  clientMutationId: String
}

type EditExternalLicenseRewardPayload {
  content: TreeNode!
  clientMutationId: String
}

input EditFeatureToggleDataInput {
  id: ID!
  data: FeatureToggleDataInput!
  clientMutationId: String
}

type EditFeatureToggleDataPayload {
  featureToggle: FeatureToggle!
  clientMutationId: String
}

input EditFileElementV2Input {
  title: String!
  fileElementId: ID!
  fileId: ID
  clientMutationId: String
}

type EditFileElementV2Payload {
  eLearningContentNode: TreeNode!
  fileElement: FileElementV2!
  clientMutationId: String
}

input EditGlobalVocabElementInput {
  title: String!
  elementId: ID!
  clientMutationId: String
}

type EditGlobalVocabElementPayload {
  eLearningContentNode: TreeNode!
  globalVocabElement: GlobalVocabElement!
  clientMutationId: String
}

input EditLicenseModelInput {
  licenseModelKind: Kind!
  clientMutationId: String
}

type EditLicenseModelPayload {
  clientMutationId: String
}

input EditLicenseProductInput {
  title: String!
  isHidden: Boolean!
  isTaxFree: Boolean!
  licenseDefinitionAmount: Int
  costUnit: String
  id: ID!
  netPrice: BigDecimal!
  licenseDefinitionId: ID!
  clientMutationId: String
}

type EditLicenseProductPayload {
  product: LicenseProduct!
  clientMutationId: String
}

input EditLimitedCartDiscountInput {
  title: String!
  percentageValue: Int!
  limitedCartDiscountId: ID!
  clientMutationId: String
}

type EditLimitedCartDiscountPayload {
  limitedCartDiscount: LimitedCartDiscount!
  clientMutationId: String
}

input EditMarkMistakesElementInput {
  newTitle: String!
  newText: String!
  markMistakesElementId: ID!
  clientMutationId: String
}

type EditMarkMistakesElementPayload {
  eLearningContent: TreeNode!
  markMistakesElement: MarkMistakesElement!
  clientMutationId: String
}

input EditMatrixElementInput {
  newTitle: String!
  matrixElementId: ID!
  clientMutationId: String
}

type EditMatrixElementPayload {
  eLearningContent: TreeNode!
  MatrixElement: MatrixElement!
  clientMutationId: String
}

input EditMicroLearningLicenseDefinitionAdminMutationInput {
  licenseDefinitionId: ID!
  data: MicroLearningLicenseDefinitionDataInput!
  clientMutationId: String
}

type EditMicroLearningLicenseDefinitionAdminMutationPayload {
  licenseDefinition: LicenseDefinition!
  clientMutationId: String
}

input EditMultipleChoiceElementV2Input {
  title: String!
  question: String!
  answeringType: String!
  answeringTypeText: String
  answerOptions: [AnswerOptionV2Input!]!
  multipleChoiceElementId: ID!
  imageIdOpt: ID
  clientMutationId: String
}

type EditMultipleChoiceElementV2Payload {
  eLearningContentNode: TreeNode!
  multipleChoiceElement: MultipleChoiceElementV2!
  clientMutationId: String
}

input EditMyAvailabilityInput {
  availabilityId: ID!
  availabilityData: AvailabilityDataInput!
  clientMutationId: String
}

type EditMyAvailabilityPayload {
  availability: Availability!
  clientMutationId: String
}

input EditMyAvailabilityScheduleInput {
  scheduleData: ScheduleDataInput!
  clientMutationId: String
}

type EditMyAvailabilitySchedulePayload {
  schedule: AvailabilitySchedule!
  clientMutationId: String
}

input EditMyBaseDataInput {
  baseData: CoachProfileBaseData!
  clientMutationId: String
}

type EditMyBaseDataPayload {
  coachProfile: CoachProfile!
  clientMutationId: String
}

input EditMyBusinessDataInput {
  businessData: BusinessDataInput!
  clientMutationId: String
}

type EditMyBusinessDataPayload {
  coachProfile: CoachProfile!
  clientMutationId: String
}

input EditMyProfileDataInput {
  profileData: ProfileDataInput!
  clientMutationId: String
}

type EditMyProfileDataPayload {
  coachProfile: CoachProfile!
  clientMutationId: String
}

input EditNodeCoreInput {
  title: String!
  description: String
  shortDescription: String
  nodeId: ID!
  imageId: ID
  instructorIds: [ID!]!
  clientMutationId: String
}

type EditNodeCorePayload {
  editedNode: TreeNode!
  clientMutationId: String
}

input EditNotAfterDateTimeVisibilityTreeConfigInput {
  newDateTime: ZonedDateTIme!
  rootNodeId: ID!
  configId: ID!
  clientMutationId: String
}

type EditNotAfterDateTimeVisibilityTreeConfigPayload {
  rootNode: TreeNode!
  clientMutationId: String
}

input EditOfferDescriptionInput {
  id: ID!
  description: CoachingOfferDescriptionInput!
  clientMutationId: String
}

type EditOfferDescriptionPayload {
  coachingOffer: CoachingOffer!
  clientMutationId: String
}

input EditOneToOneSettingInput {
  id: ID!
  setting: GroupCoachingSettingInput!
  clientMutationId: String
}

type EditOneToOneSettingPayload {
  coachingOffer: CoachingOffer!
  clientMutationId: String
}

input EditOrderElementInput {
  newTitle: String!
  newAnsweringTypeTextOpt: String
  orderElementId: ID!
  clientMutationId: String
}

type EditOrderElementPayload {
  eLearningContentNode: TreeNode!
  orderElement: OrderElement!
  clientMutationId: String
}

input EditOrderItemInput {
  newText: String!
  orderElementId: ID!
  orderItemId: ID!
  clientMutationId: String
}

type EditOrderItemPayload {
  orderElement: OrderElement!
  clientMutationId: String
}

input EditPercentageDiscountActionInput {
  newTitle: String!
  newDiscountType: String!
  newPercentage: BigDecimal!
  newUsageLimitation: UpdateUsageLimited
  newValidUntil: ZonedDateTIme
  discountActionId: ID!
  clientMutationId: String
}

type EditPercentageDiscountActionPayload {
  discountAction: DiscountAction!
  clientMutationId: String
}

input EditPlacementProductInput {
  title: String!
  isTaxFree: Boolean!
  costUnit: String
  id: ID!
  netPrice: BigDecimal!
  clientMutationId: String
}

type EditPlacementProductPayload {
  product: PlacementProduct!
  clientMutationId: String
}

input EditPodcastWithTimestampInput {
  newTitle: String!
  elementId: ID!
  newPodcastFileId: ID!
  newTimestampsWithImage: [TimestampWithImageInput!]!
  clientMutationId: String
}

type EditPodcastWithTimestampPayload {
  eLearningContent: TreeNode!
  podcastWithTimestampElement: PodcastWithTimestamp!
  clientMutationId: String
}

input EditPodigeePodcastElementV2Input {
  title: String!
  podigeeUrl: String!
  lengthInSeconds: Int!
  podigeePodcastElementId: ID!
  clientMutationId: String
}

type EditPodigeePodcastElementV2Payload {
  eLearningContentNode: TreeNode!
  podigeePodcastElement: PodcastElementV2!
  clientMutationId: String
}

input EditPrivateBaseDataAdminInput {
  accountId: ID!
  baseData: PrivateBaseDataInput!
  clientMutationId: String
}

type EditPrivateBaseDataAdminPayload {
  baseData: PrivateBaseData!
  clientMutationId: String
}

input EditPrivateBaseDataInput {
  baseData: PrivateBaseDataInput!
  clientMutationId: String
}

type EditPrivateBaseDataPayload {
  baseData: PrivateBaseData!
  clientMutationId: String
}

input EditProductSelectionConditionInput {
  amount: Int!
  limitedCartDiscountId: ID!
  conditionId: ID!
  productId: ID!
  clientMutationId: String
}

type EditProductSelectionConditionPayload {
  limitedCartDiscount: LimitedCartDiscount!
  clientMutationId: String
}

input EditProfileDataInput {
  coachProfileId: ID!
  profileData: ProfileDataInput!
  clientMutationId: String
}

type EditProfileDataPayload {
  edge: CoachProfileEdge!
  clientMutationId: String
}

input EditRenumerationInput {
  percentageShare: Int!
  additionalInformation: String
  id: ID!
  sessionRate: PriceInput!
  clientMutationId: String
}

type EditRenumerationPayload {
  coachingOffer: CoachingOffer!
  clientMutationId: String
}

input EditRootNodePartInput {
  searchWords: String
  firstReleasedAt: ZonedDateTIme
  rootNodeId: ID!
  iconId: ID
  tagIds: [ID!]!
  clientMutationId: String
}

type EditRootNodePartPayload {
  editedNode: TreeNode!
  clientMutationId: String
}

input EditSingleUserAssignmentRuleInput {
  maxLicenseAmount: Int!
  assignmentRuleId: ID!
  userId: ID!
  clientMutationId: String
}

type EditSingleUserAssignmentRulePayload {
  assignmentRule: AssignmentRule!
  clientMutationId: String
}

input editTagInput {
  data: TagDataInput!
  id: ID!
  clientMutationId: String
}

type editTagPayload {
  tag: AcademiesTag!
  clientMutationId: String
}

input EditTextElementV2Input {
  title: String!
  text: String!
  textElementId: ID!
  clientMutationId: String
}

type EditTextElementV2Payload {
  eLearningContentNode: TreeNode!
  textElement: TextElementV2!
  clientMutationId: String
}

input EditTreeLicenseDefinitionAdminMutationInput {
  licenseDefinitionId: ID!
  data: TreeLicenseDefinitionDataInput!
  clientMutationId: String
}

type EditTreeLicenseDefinitionAdminMutationPayload {
  licenseDefinition: LicenseDefinition!
  clientMutationId: String
}

input EditTrendInput {
  trendId: ID!
  trendData: TrendDataInput!
  trendMedia: TrendMediaInput!
  customerData: CustomerDataInput!
  coachingImageId: ID!
  potentialAnalysisHeadingAndDescription: HeadingAndDescriptionInput!
  coachingHeadingAndDescription: HeadingAndDescriptionInput!
  aboutOffersHeadingAndDescription: HeadingAndDescriptionInput!
  clientMutationId: String
}

type EditTrendPayload {
  edge: TrendEdge!
  clientMutationId: String
}

input EditUploadAsyncElementInput {
  title: String!
  taskDescription: String!
  id: ID!
  assignedEvaluator: ID!
  clientMutationId: String
}

type EditUploadAsyncElementPayload {
  asyncContent: TreeNode!
  uploadAsyncElement: UploadAsyncElement!
  clientMutationId: String
}

input EditUserInAccountGroupAndAddOrInviteUsersMutationInput {
  newName: String!
  emails: [String!]!
  id: ID!
  clientMutationId: String
}

type EditUserInAccountGroupAndAddOrInviteUsersMutationPayload {
  group: UserInAccountGroupWrapper
  clientMutationId: String
}

input EditUserInput {
  email: String!
  activated: Boolean!
  firstName: String!
  lastName: String!
  position: String
  adsOptIn: Boolean!
  userId: ID!
  imageId: ID
  branch: Branch
  teamSize: TeamSize
  clientMutationId: String
}

type EditUserPayload {
  user: User!
  clientMutationId: String
}

input EditVideoElementV2Input {
  title: String!
  vimeoId: String!
  videoElementId: ID!
  clientMutationId: String
}

type EditVideoElementV2Payload {
  eLearningContentNode: TreeNode!
  videoElement: VideoElement!
  clientMutationId: String
}

input EditVimeoPodcastElementV2Input {
  title: String!
  vimeoId: String!
  vimeoPodcastElementId: ID!
  clientMutationId: String
}

type EditVimeoPodcastElementV2Payload {
  eLearningContentNode: TreeNode!
  vimeoPodcastElement: PodcastElementV2!
  clientMutationId: String
}

input EditWordInput {
  word: String!
  translation: String
  explanation: String!
  wordPackageId: ID!
  wordId: ID!
  clientMutationId: String
}

input EditWordPackageInput {
  wordPackageId: ID!
  data: WordPackageDataInput!
  clientMutationId: String
}

type EditWordPackagePayload {
  wordPackage: WordPackage!
  clientMutationId: String
}

input EditWordPackageRewardInput {
  newData: WordPackageRewardDataInput!
  contentId: ID!
  rewardId: ID!
  clientMutationId: String
}

type EditWordPackageRewardPayload {
  content: TreeNode!
  clientMutationId: String
}

type EditWordPayload {
  wordPackage: WordPackage!
  clientMutationId: String
}

input EditWrongAnswerInMatrixElementCellInput {
  wrongAnswerContent: String!
  matrixElementId: ID!
  matrixCellId: ID!
  wrongAnswerId: ID!
  clientMutationId: String
}

type EditWrongAnswerInMatrixElementCellPayload {
  eLearningContent: TreeNode!
  matrixElement: MatrixElement!
  clientMutationId: String
}

interface ELearningContentSubmissionDefinition {
  progress: ELearningContentSubmissionProgress!
  relativeProgress: ELearningContentSubmissionRelativeProgress!
  status: ContentSubmissionStatus!
  contentKind: ContentKind!
}

interface ELearningContentSubmissionProgress {
  percentage: Int!
}

type ELearningContentSubmissionRelativeProgress {
  numElements: Int!
  numCorrect: Int!
  percentageCorrect: Int!
}

type ELearningContentTypeDefinition implements ContentTypeDefinition & TypeDefinition {
  elements: [ElementV2!]!
  flowConfig: FlowELearningContentConfig!
  extension: ContentExtension!
  continueConfig: ContinueContentConfig!
  passConfig: PassContentConfig!
  restartIfFailedConfigs: [RestartIfFailedContentConfig!]!
  restartIfPassedConfig: RestartIfPassedContentConfig!
  rewardConfig: RewardContentConfig!
  rewards: [Reward!]!
  startConfigs: [StartContentConfig!]!
  contentKind: ContentKind!
  definitionType: TypeDefinitionType!
}

type ELearningMutations {
  goToPreviousElement(input: GoToPreviousElementInput!): GoToPreviousElementPayload
  goToNextElement(input: GoToNextElementInput!): GoToNextElementPayload
  canShowElementAnswer(input: CanShowElementAnswerInput!): CanShowElementAnswerPayload
  showElementAnswerElement(input: ShowElementAnswerElementInput!): ShowElementAnswerElementPayload
  canSubmitElement(input: CanSubmitElementInput!): CanSubmitElementPayload
}

"""Data only accessible by the admin"""
type ElearningV2AdminMutationSchema {
  createMatrixElement(input: CreateMatrixElementInput!): CreateMatrixElementPayload
  editMatrixElement(input: EditMatrixElementInput!): EditMatrixElementPayload
  addColumnToMatrixElement(input: AddColumnToMatrixElementInput!): AddColumnToMatrixElementPayload
  addRowToMatrixElement(input: AddRowToMatrixElementInput!): AddRowToMatrixElementPayload
  removeColumnFromMatrixElement(input: RemoveColumnFromMatrixElementInput!): RemoveColumnFromMatrixElementPayload
  removeRowFromMatrixElement(input: RemoveRowFromMatrixElementInput!): RemoveRowFromMatrixElementPayload
  setMatrixElementColumnTitle(input: SetMatrixElementColumnTitleInput!): SetMatrixElementColumnTitlePayload
  setMatrixElementRowTitle(input: SetMatrixElementRowTitleInput!): SetMatrixElementRowTitlePayload
  setCorrectAnswerInMatrixElementCell(input: SetCorrectAnswerInMatrixElementCellInput!): SetCorrectAnswerInMatrixElementCellPayload
  addWrongAnswerInMatrixElementCell(input: AddWrongAnswerInMatrixElementCellInput!): AddWrongAnswerInMatrixElementCellPayload
  removeWrongAnswerFromMatrixElementCell(input: RemoveWrongAnswerFromMatrixElementCellInput!): RemoveWrongAnswerFromMatrixElementCellPayload
  editWrongAnswerInMatrixElementCell(input: EditWrongAnswerInMatrixElementCellInput!): EditWrongAnswerInMatrixElementCellPayload
  createDynamicVocabElement(input: CreateDynamicVocabElementInput!): CreateDynamicVocabElementPayload
  editDynamicVocabElement(input: EditDynamicVocabElementInput!): EditDynamicVocabElementPayload
  createFileElement(input: CreateFileElementV2Input!): CreateFileElementV2Payload
  editFileElement(input: EditFileElementV2Input!): EditFileElementV2Payload
  createVideoElement(input: CreateVideoElementV2Input!): CreateVideoElementV2Payload
  editVideoElement(input: EditVideoElementV2Input!): EditVideoElementV2Payload
  getVideoData(input: GetVideoDataV2Input!): GetVideoDataV2Payload
  createMultipleChoiceElement(input: CreateMultipleChoiceElementV2Input!): CreateMultipleChoiceElementV2Payload
  editMultipleChoiceElement(input: EditMultipleChoiceElementV2Input!): EditMultipleChoiceElementV2Payload
  createPodcastElement(input: CreatePodcastElementV2Input!): CreatePodcastElementV2Payload
  editVimeoPodcastElement(input: EditVimeoPodcastElementV2Input!): EditVimeoPodcastElementV2Payload
  editPodigeePodcastElement(input: EditPodigeePodcastElementV2Input!): EditPodigeePodcastElementV2Payload
  createEnhancedTextElement(input: CreateEnhancedTextElementInput!): CreateEnhancedTextElementPayload
  editEnhancedTextElement(input: EditEnhancedTextElementInput!): EditEnhancedTextElementPayload
  createTextElement(input: CreateTextElementV2Input!): CreateTextElementV2Payload
  editTextElement(input: EditTextElementV2Input!): EditTextElementV2Payload
  deleteElement(input: DeleteElementV2Input!): DeleteElementV2Payload
  rearrangeElements(input: RearrangeElementsV2Input!): RearrangeElementsV2Payload
  createPodcastWithTimestampElement(input: CreatePodcastWithTimestampInput!): CreatePodcastWithTimestampPayload
  editPodcastWithTimestampElement(input: EditPodcastWithTimestampInput!): EditPodcastWithTimestampPayload
  createClozeTextElement(input: CreateClozeTextElementV2Input!): CreateClozeTextElementV2Payload
  editClozeTextElement(input: EditClozeTextElementV2Input!): EditClozeTextElementV2Payload
  createMarkMistakesElement(input: CreateMarkMistakesElementInput!): CreateMarkMistakesElementPayload
  editMarkMistakesElement(input: EditMarkMistakesElementInput!): EditMarkMistakesElementPayload
  createOrderElement(input: CreateOrderElementInput!): CreateOrderElementPayload
  addOrderItem(input: AddOrderItemInput!): AddOrderItemPayload
  editOrderElement(input: EditOrderElementInput!): EditOrderElementPayload
  editOrderItem(input: EditOrderItemInput!): EditOrderItemPayload
  moveOrderItems(input: MoveOrderItemsInput!): MoveOrderItemsPayload
  removeOrderItem(input: RemoveOrderItemInput!): RemoveOrderItemPayload
  createGlobalVocabElement(input: CreateGlobalVocabElementInput!): CreateGlobalVocabElementPayload
  editGlobalVocabElement(input: EditGlobalVocabElementInput!): EditGlobalVocabElementPayload
}

interface ElementExtension {
  doNotUse: String!
}

type ElementExtensionImpl implements ElementExtension {
  points: Int!
  doNotUse: String!
}

type ElementsSummary {
  numFileElements: Int!
  sumTextLengthInSec: Int!
  sumVideoLengthInSec: Int!
  sumPodcastWithTimestampLengthInSec: Int!
  numExerciseElements: Int!
}

interface ElementState {
  element: LearnElement!
  kind: ElementStateKind!
}

enum ElementStateKind {
  Untouched
  UntouchedAndPreviouslyIncorrect
  Input
  ShowAnswer
  InputAndIsCorrect
}

enum ElementTypeV2 {
  matrix
  dynamicVocab
  file
  video
  multipleChoice
  podcast
  enhancedText
  text
  podcastWithTimestamp
  clozeText
  markMistakes
  order
  globalVocab
}

interface ElementV2 {
  """The ID of an object"""
  id: ID!
  title: String!
  elementType: ElementTypeV2!
  extension: ElementExtension!
}

"""Data only accessible by the admin"""
type EmailAdminMutationSchema {
  createPersonalizedEmailTemplate(input: CreatePersonalizedEmailTemplateInput!): CreatePersonalizedEmailTemplatePayload
  updatePersonalizedEmailTemplate(input: UpdatePersonalizedEmailTemplateInput!): UpdatePersonalizedEmailTemplatePayload
  deletePersonalizedEmailTemplate(input: DeletePersonalizedEmailTemplateInput!): DeletePersonalizedEmailTemplatePayload
  sendEmail(input: SendEmailInput!): SendEmailPayload
}

"""Data only accessible by the admin"""
type EmailAdminSchema {
  AvailableSystemTemplates(before: String, after: String, first: Int, last: Int): [EmailTemplate!]!
  PersonalizedEmailTemplates(before: String, after: String, first: Int, last: Int): PersonalizedEmailTemplatesConnection!
}

type EmailTemplate {
  key: String!
  subject: String!
  previewText: String!
  body: String!
  variables: [String!]!
}

type EmployerInvoicePaymentMethod implements SelectedPaymentMethod {
  selectedPaymentMethodType: SelectedPaymentMethodType!
  paymentMethodId: PaymentMethodType!
}

type EnhancedTextElement implements ElementV2 {
  text: String!
  readMore: String
  readMoreButtonText: String

  """The ID of an object"""
  id: ID!
  title: String!
  elementType: ElementTypeV2!
  extension: ElementExtension!
}

type EnhancedTextLearnElement implements LearnElement {
  text: String!
  readMore: String
  readMoreButtonText: String

  """The ID of an object"""
  id: ID!
  title: String!
  elementType: ElementTypeV2!
}

type EvaluatedUploadAsyncElementTask implements UploadAsyncElementTask & AsyncElementTask & Node {
  evaluation: UploadEvaluation!
  file: File
  id: ID!
  submissionInfo: AsyncElementTaskSubmissionInfo!
  elementKind: AsyncElementKind!
  extension: AsyncElementTaskExtension!
  assignedEvaluator: User
  status: AsyncElementTaskStatus!
}

input EvaluateUploadAsyncElementTaskInput {
  text: String
  taskId: ID!
  fileId: ID!
  clientMutationId: String
}

type EvaluateUploadAsyncElementTaskPayload {
  evaluatedTask: EvaluatedUploadAsyncElementTask!
  clientMutationId: String
}

type ExternalLicense implements Node {
  """The ID of an object"""
  id: ID!
  data: ExternalLicenseData!
  pool: ExternalLicensePool
  issuingInfo: ExternalLicenseIssuingInfoInterface!
}

type ExternalLicense_ErrorOccurredRewardResult implements RewardResult {
  rewardId: ID!
  rewardKind: RewardKind!
  kind: RewardResultKind!
}

type ExternalLicense_IssuedToUserRewardResult implements RewardResult {
  rewardId: ID!
  rewardKind: RewardKind!
  kind: RewardResultKind!
}

type ExternalLicense_NotPassedRewardResult implements RewardResult {
  rewardId: ID!
  rewardKind: RewardKind!
  kind: RewardResultKind!
}

type ExternalLicenseData {
  name: String!
  code: String!
}

input ExternalLicenseDataInput {
  name: String
  code: String
}

type ExternalLicenseIssuedToUserIssuingInfoType implements ExternalLicenseIssuingInfoInterface {
  issuedTo: User
  issuedAt: ZonedDateTIme!
  validUntil: ZonedDateTIme!
  hasBeenIssued: Boolean!
  kind: ExternalLicenseIssuingInfoKind!
}

interface ExternalLicenseIssuingInfoInterface {
  hasBeenIssued: Boolean!
  kind: ExternalLicenseIssuingInfoKind!
}

enum ExternalLicenseIssuingInfoKind {
  issuedToUser
  notIssued
}

type ExternalLicenseNotIssuedIssuingInfoType implements ExternalLicenseIssuingInfoInterface {
  hasBeenIssued: Boolean!
  kind: ExternalLicenseIssuingInfoKind!
}

type ExternalLicensePool implements Node {
  """The ID of an object"""
  id: ID!
  data: ExternalLicensePoolData!
  canBeDeleted: Boolean!
}

type ExternalLicensePoolData {
  name: String!
  validNumDaysAfterIssuing: Int!
  usageInformation: String!
  link: String
}

input ExternalLicensePoolDataInput {
  name: String!
  validNumDaysAfterIssuing: Int!
  usageInformation: String!
  link: String
}

"""A connection to a list of items."""
type ExternalLicensePoolsConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [ExternalLicensePoolsEdge]
}

"""An edge in a connection."""
type ExternalLicensePoolsEdge {
  """The item at the end of the edge."""
  node: ExternalLicensePool!

  """A cursor for use in pagination."""
  cursor: String!
}

type ExternalLicenseReward implements Reward {
  data: ExternalLicenseRewardData!

  """The ID of an object"""
  id: ID!
  superId: ID!
  kind: RewardKind!
}

type ExternalLicenseRewardData {
  pool: ExternalLicensePool
}

input ExternalLicenseRewardDataInput {
  pool: ID!
}

"""A connection to a list of items."""
type ExternalLicensesConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [ExternalLicensesEdge]
}

"""An edge in a connection."""
type ExternalLicensesEdge {
  """The item at the end of the edge."""
  node: ExternalLicense!

  """A cursor for use in pagination."""
  cursor: String!
}

type FailedELearningContentSubmissionDefinition implements FinishedELearningContentSubmissionDefinitionInterface & ELearningContentSubmissionDefinition & ContentSubmissionDefinition {
  rewardResults: [RewardResult!]!
  progress: ELearningContentSubmissionProgress!
  relativeProgress: ELearningContentSubmissionRelativeProgress!
  status: ContentSubmissionStatus!
  contentKind: ContentKind!
}

enum FeatureId {
  test
  potentialAnalysisV2
}

type FeatureToggle implements Node {
  """The ID of an object"""
  id: ID!
  data: FeatureToggleData!
}

"""Data only accessible by the admin"""
type FeatureToggleAdminMutationSchema {
  editFeatureToggleData(input: EditFeatureToggleDataInput!): EditFeatureToggleDataPayload
}

"""Data only accessible by the admin"""
type FeatureToggleAdminSchema {
  FeatureToggles(before: String, after: String, first: Int, last: Int, filterByName: String, filterByIsActive: Boolean): FeatureTogglesConnection!
}

type FeatureToggleData {
  name: String!
  isActive: Boolean!
}

input FeatureToggleDataInput {
  name: String!
  isActive: Boolean!
}

type FeatureToggleQueries {
  ActiveFeatureToggleIds: [FeatureId!]!
}

"""A connection to a list of items."""
type FeatureTogglesConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [FeatureTogglesEdge]
}

"""An edge in a connection."""
type FeatureTogglesEdge {
  """The item at the end of the edge."""
  node: FeatureToggle!

  """A cursor for use in pagination."""
  cursor: String!
}

input FeedbackData {
  score: Int!
  comment: String
}

type File implements Node {
  name: String!
  fileType: String!
  fileSize: Long!
  storageKey: String!
  thumbnailKey: String
  accessType: FileAccessType!
  tags: [String!]!
  uploadDateTime: ZonedDateTIme!

  """The ID of an object"""
  id: ID!
  thumbnail: String
  url: String
}

enum FileAccessType {
  public
  signedUrl
}

interface FileAttachment {
  file: File

  """The ID of an object"""
  id: ID!
  title: String
  description: String
  kind: AttachmentKind!
}

enum FileContentTypeV2 {
  pdf
  png
  jpg
}

type FileElementV2 implements ElementV2 {
  file: File
  fileContentType: FileContentTypeV2!

  """The ID of an object"""
  id: ID!
  title: String!
  elementType: ElementTypeV2!
  extension: ElementExtension!
}

type FileLearnElement implements LearnElement {
  file: File
  fileContentType: FileContentTypeV2!

  """The ID of an object"""
  id: ID!
  title: String!
  elementType: ElementTypeV2!
}

"""Data only accessible by the admin"""
type FilesAdminMutationSchema {
  deleteFile(input: DeleteFileInput!): DeleteFilePayload
}

"""Data only accessible by the admin"""
type FilesAdminSchema {
  Files(before: String, after: String, first: Int, last: Int, name: String, fileType: [String!], fromDateTimeInclusive: ZonedDateTIme, toDateTimeInclusive: ZonedDateTIme, tagsIncluded: [String!], tagsExcluded: [String!]): FilesConnection!
}

"""A connection to a list of items."""
type FilesConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [FilesEdge]
}

"""An edge in a connection."""
type FilesEdge {
  """The item at the end of the edge."""
  node: File!

  """A cursor for use in pagination."""
  cursor: String!
}

interface FinishedAsyncContentSubmissionDefinitionInterface {
  rewardResults: [RewardResult!]!
  element: AsyncLearnElement
  status: ContentSubmissionStatus!
  contentKind: ContentKind!
}

interface FinishedELearningContentSubmissionDefinitionInterface {
  rewardResults: [RewardResult!]!
  progress: ELearningContentSubmissionProgress!
  relativeProgress: ELearningContentSubmissionRelativeProgress!
  status: ContentSubmissionStatus!
  contentKind: ContentKind!
}

type FinishedELearningContentSubmissionProgress implements ELearningContentSubmissionProgress {
  percentage: Int!
}

type FirstContentStartAtTreeConfig implements StartAtTreeConfig {
  """The ID of an object"""
  id: ID!
  configType: StartAtTreeConfigType!
}

interface FlowELearningContentConfig {
  """The ID of an object"""
  id: ID!
  configType: FlowELearningContentConfigType!
}

enum FlowELearningContentConfigType {
  FlowELearningContent_DirectFeedback
  FlowELearningContent_SimplyContinue
}

input ForgotPasswordInput {
  email: String!
  clientMutationId: String
}

type ForgotPasswordPayload {
  clientMutationId: String
}

type FreshUploadAsyncElementTask implements UploadAsyncElementTask & AsyncElementTask & Node {
  file: File
  id: ID!
  submissionInfo: AsyncElementTaskSubmissionInfo!
  elementKind: AsyncElementKind!
  extension: AsyncElementTaskExtension!
  assignedEvaluator: User
  status: AsyncElementTaskStatus!
}

interface GamificationPoints {
  id: ID!
  num: Int!
  owner: User
  receivedAt: ZonedDateTIme!
  kind: GamificationPointsKind!
}

type GamificationPoints_AlreadyReceivedPointsRewardResult implements RewardResult {
  rewardId: ID!
  rewardKind: RewardKind!
  kind: RewardResultKind!
}

type GamificationPoints_ErrorOccurredRewardResult implements RewardResult {
  rewardId: ID!
  rewardKind: RewardKind!
  kind: RewardResultKind!
}

type GamificationPoints_NoPointsReceivedRewardResult implements RewardResult {
  rewardId: ID!
  rewardKind: RewardKind!
  kind: RewardResultKind!
}

type GamificationPoints_NotPassedIHKTestFlowRewardResult implements RewardResult {
  rewardId: ID!
  rewardKind: RewardKind!
  kind: RewardResultKind!
}

type GamificationPoints_PointsReceivedRewardResult implements RewardResult {
  points: GamificationPointsReceivedByContent
  rewardId: ID!
  rewardKind: RewardKind!
  kind: RewardResultKind!
}

enum GamificationPointsKind {
  ReceivedByContent
}

type GamificationPointsReceivedByContent implements GamificationPoints {
  contentId: ID!
  id: ID!
  num: Int!
  owner: User
  receivedAt: ZonedDateTIme!
  kind: GamificationPointsKind!
}

type GamificationPointsReward implements Reward {
  """The ID of an object"""
  id: ID!
  superId: ID!
  kind: RewardKind!
}

enum Gender {
  Male
  Female
  Diverse
  NotDefined
}

input GenerateAbsoluteCartLinkInput {
  selectedDiscountCodes: [String!]!
  selectedProducts: [CartLinkProductsInput!]!
  clientMutationId: String
}

type GenerateAbsoluteCartLinkPayload {
  link: String!
  clientMutationId: String
}

type GetActiveContentNodeOrFallbackRoot_ActiveContentNode implements GetActiveContentNodeOrFallbackRoot_Result {
  contentNode: LearnOpportunityV2!
  kind: GetActiveContentNodeOrFallbackRoot_ResultKind!
}

type GetActiveContentNodeOrFallbackRoot_Empty implements GetActiveContentNodeOrFallbackRoot_Result {
  kind: GetActiveContentNodeOrFallbackRoot_ResultKind!
}

type GetActiveContentNodeOrFallbackRoot_FallbackRoot implements GetActiveContentNodeOrFallbackRoot_Result {
  fallbackRoot: LearnOpportunityV2!
  kind: GetActiveContentNodeOrFallbackRoot_ResultKind!
}

interface GetActiveContentNodeOrFallbackRoot_Result {
  kind: GetActiveContentNodeOrFallbackRoot_ResultKind!
}

enum GetActiveContentNodeOrFallbackRoot_ResultKind {
  ActiveContentNode
  FallbackRoot
  Empty
}

input GetVideoDataV2Input {
  vimeoId: String!
  clientMutationId: String
}

type GetVideoDataV2Payload {
  videoData: VideoDataV2
  clientMutationId: String
}

type GlobalVocabElement implements ElementV2 {
  """The ID of an object"""
  id: ID!
  title: String!
  elementType: ElementTypeV2!
  extension: ElementExtension!
}

type GoogleIAPData implements PaymentProviderData {
  paymentMethod: PaymentMethodType!
  dataType: PaymentProviderDataType!
  receipt: String!
  orderId: ID!
}

input GoToNextElementInput {
  contentSubmissionId: ID!
  clientMutationId: String
}

type GoToNextElementPayload {
  contentSubmission: ContentSubmission!
  clientMutationId: String
}

input GoToPreviousElementInput {
  contentSubmissionId: ID!
  clientMutationId: String
}

type GoToPreviousElementPayload {
  contentSubmission: ContentSubmission!
  clientMutationId: String
}

input GrantPlacementPermissionAndRedirectInput {
  clientMutationId: String
}

type GrantPlacementPermissionAndRedirectPayload {
  placementUrl: String!
  clientMutationId: String
}

type GroupCoachingSetting implements CoachingSetting {
  kind: CoachingSettingKind!
  maxParticipants: Int!
}

input GroupCoachingSettingInput {
  maxParticipants: Int!
  kind: CoachingSettingKind
}

type HeadingAndDescription {
  heading: String!
  description: String!
}

input HeadingAndDescriptionInput {
  heading: String!
  description: String!
}

type HideVisibilityCoachingConfig implements VisibilityCoachingConfig {
  """The ID of an object"""
  id: ID!
  configType: VisibilityCoachingConfigType!
}

type HideVisibilityTreeConfig implements VisibilityTreeConfig {
  """The ID of an object"""
  id: ID!
  configType: VisibilityTreeConfigType!
}

interface HistoryEventInterface {
  kind: HistoryEventType!
}

enum HistoryEventType {
  OrderCreationUpdate
  CartUpdate
  BillingDetailsUpdate
  PaymentMethodUpdate
  PaymentInProcessUpdate
  PurchaseUpdate
  InvoiceSentUpdate
  CreditNoteSentUpdate
}

"""Data only accessible by the admin"""
type HubspotAdminMutationSchema {
  syncHubspotContactsWithUsers(input: SyncHubspotContactsWithUsersInput!): SyncHubspotContactsWithUsersPayload
}

enum Icon {
  dotsConnected
  arrowLoop
  personWithStars
  computerWithHeart
  bridgeOverRiver
  peopleHighFive
  handWithFlower
  handsWithHeart
  flowerInCircle
  lightBulb
  workingDesk
  rocket
}

type IHKCertificate_ErrorOccurredRewardResult implements RewardResult {
  rewardId: ID!
  rewardKind: RewardKind!
  kind: RewardResultKind!
}

type IHKCertificate_NotPassedRewardResult implements RewardResult {
  rewardId: ID!
  rewardKind: RewardKind!
  kind: RewardResultKind!
}

type IHKCertificate_ReadyToOrderRewardResult implements RewardResult {
  rewardId: ID!
  rewardKind: RewardKind!
  kind: RewardResultKind!
}

enum IHKCertificateOrderStateKind {
  NotIHK
  RewardNotAchievedYet
  Ordered
  ReadyToOrder
  ErrorOccurred
}

input IHKCertificateOrderUserDataInput {
  title: String
  salutation: String
  firstName: String!
  lastName: String!
  dateOfBirth: LocalDate!
  street: String!
  houseNumber: String!
  postalCode: String!
  city: String!
  country: String!
}

type IHKCertificateReward implements Reward {
  """The ID of an object"""
  id: ID!
  superId: ID!
  kind: RewardKind!
}

type IHKFlowPassContentConfig implements PassContentConfig {
  """The ID of an object"""
  id: ID!
  configType: PassContentConfigType!
}

type ImageTrendMedia implements TrendMedia {
  file: File
  kind: TrendMediaKind!
}

input ImageTrendMediaInput {
  fileId: ID!
  trendMediaType: TrendMediaKind!
}

input InformAboutSuccessfulPlacementInput {
  jobListingTitle: String!
  accountId: ID!
  clientMutationId: String
}

type InformAboutSuccessfulPlacementPayload {
  clientMutationId: String
}

input InitializeFreeCalendarWeekOverrideInput {
  clientMutationId: String
}

type InitializeFreeCalendarWeekOverridePayload {
  schedule: AvailabilitySchedule!
  clientMutationId: String
}

type InputAndIsCorrectElementState implements ElementState {
  inputElementState: InputElementState!
  isCorrect: Boolean!
  element: LearnElement!
  kind: ElementStateKind!
}

interface InputElementState {
  element: LearnElement!
  kind: ElementStateKind!
}

interface Instructor {
  """The ID of an object"""
  id: ID!
  superId: ID!
  name: String!
}

"""Data only accessible by the admin"""
type InstructorAdminMutationSchema {
  createInstructorImpl(input: CreateInstructorImplInput!): CreateInstructorImplPayload
  updateInstructorImpl(input: UpdateInstructorImplInput!): UpdateInstructorImplPayload
  deleteInstructorImpl(input: DeleteInstructorImplInput!): DeleteInstructorImplPayload
}

"""Data only accessible by the admin"""
type InstructorAdminSchema {
  InstructorImpls(before: String, after: String, first: Int, last: Int): InstructorImplsConnection!
}

type InstructorImpl implements Instructor & Node {
  """The ID of an object"""
  id: ID!
  name: String!
  shortDescription: String
  description: String
  image: File
  position: String
  superId: ID!
}

input InstructorImplInput {
  name: String!
  shortDescription: String
  description: String
  position: String
  clientMutationId: String
  imageId: ID
}

"""A connection to a list of items."""
type InstructorImplsConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [InstructorImplsEdge]
}

"""An edge in a connection."""
type InstructorImplsEdge {
  """The item at the end of the edge."""
  node: InstructorImpl!

  """A cursor for use in pagination."""
  cursor: String!
}

"""A connection to a list of items."""
type InstructorsConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [InstructorsEdge]
}

"""An edge in a connection."""
type InstructorsEdge {
  """The item at the end of the edge."""
  node: Instructor!

  """A cursor for use in pagination."""
  cursor: String!
}

type Invitation {
  """The ID of an object"""
  id: ID!
  email: String!
  addToGroups: [UserInAccountGroup!]!
  validUntil: ZonedDateTIme
  invitingUser: User
  invitingUserName: String
  accountName: String
}

type InvitationWrapper implements AccountMember {
  invitation: Invitation!
  id: ID!
  name: String!
  groups: [UserInAccountGroup!]!
  isManager: Boolean!
  kind: AccountMemberKind!
}

input InviteOrAddUsersToUserInAccountGroupsInput {
  emails: [String!]!
  groupIds: [ID!]!
  clientMutationId: String
}

type InviteOrAddUsersToUserInAccountGroupsPayload {
  updatedAccountMembers: [AccountMember!]!
  newAccountMembers: [AccountMemberEdge!]!
  clientMutationId: String
}

type InvoiceAddress {
  companyDetails: String
  companyName: String!
  houseNumber: String!
  postalCode: String!
  firstName: String!
  lastName: String!
  country: String!
  street: String!
  city: String!
}

type InvoiceData {
  invoiceId: String!
  invoiceNumber: String
  invoiceFile: File
}

type InvoiceSentUpdate implements HistoryEventInterface {
  invoiceId: String!
  invoiceNumber: String!
  kind: HistoryEventType!
}

type IsFinishedViewerTreeState implements ViewerTreeState {
  startedAt: ZonedDateTIme!
  kind: ViewerTreeStateKind!
}

type IsStartedViewerTreeState implements ViewerTreeState {
  headContentId: ID!
  startedAt: ZonedDateTIme!
  kind: ViewerTreeStateKind!
}

input IssueExternalLicenseInput {
  externalLicenseId: ID!
  issuedToUser: ID!
  clientMutationId: String
}

type IssueExternalLicensePayload {
  edge: ExternalLicensesEdge!
  clientMutationId: String
}

interface Item {
  itemType: ItemType!
}

enum ItemType {
  CartProduct
  CartBulkDiscount
  CartDiscount
  CartLimitedDiscount
  CartGlobalDiscount
}

type JwtLoginInformation {
  accessToken: String!
  refreshToken: String!
}

enum Kind {
  Assigment
  FreeForAll
}

"""Data only accessible by the admin"""
type LearnableAdminSchema {
  UnpublishedLearnables(before: String, after: String, first: Int, last: Int, text: String, isVisible: Boolean, tagIds: [ID!]!, kinds: [LearnableKind!]!): UnpublishedLearnablesConnection!
}

enum LearnableKind {
  MicroLearning
  OneToOneCoaching
  Course
  GroupCoaching
}

type LearnableLicenseGrouping implements LicenseGrouping {
  learnable: PublishedLearnable
  id: ID!
  totalLicenseAmount: Int!
  usedLicenseAmount: Int!
  totalLicenseAmountForUser: Int!
  usedLicenseAmountForUser: Int!
  assignmentRules: [AssignmentRule!]!
  kind: LicenseGroupingKind!
}

type LearnableQueries {
  PublishedLearnables(before: String, after: String, first: Int, last: Int, text: String, tagIds: [ID!]!, kinds: [LearnableKind!]!): PublishedLearnablesConnection!
}

type LearnableWithLastUpdated {
  learnable: PublishedLearnable!
  lastUpdated: ZonedDateTIme
}

type LearnAsyncContentTypeDefinition implements LearnOpportunityContentTypeDefinition & LearnOpportunityTypeDefinition {
  task: AsyncElementTask
  taskDescription: String
  contentNodeAdvancementResult: ContentNodeAdvancementResult!
  contentKind: ContentKind!
  extension: LearnContentExtension!
  definitionType: TypeDefinitionType!
}

interface LearnContentExtension {
  doNotUse: String!
}

type LearnContentExtensionImpl implements LearnContentExtension {
  elementsSummary: ElementsSummary
  image: File
  instructors(before: String, after: String, first: Int, last: Int): InstructorsConnection!
  isUnlockNecessaryToStart: Boolean!
  receivableGamificationPoints: Int!
  receivedGamificationPoints: Int!
  doNotUse: String!
}

interface LearnElement {
  """The ID of an object"""
  id: ID!
  title: String!
  elementType: ElementTypeV2!
}

type LearnMutations {
  orderIHKCertificate(input: OrderIHKCertificateInput!): OrderIHKCertificatePayload
}

"""A connection to a list of items."""
type LearnOpportunitiesV2Connection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [LearnOpportunitiesV2Edge]
}

"""An edge in a connection."""
type LearnOpportunitiesV2Edge {
  """The item at the end of the edge."""
  node: LearnOpportunityV2!

  """A cursor for use in pagination."""
  cursor: String!
}

type LearnOpportunityBranchTypeDefinition implements LearnOpportunityTypeDefinition {
  children: [LearnOpportunityV2!]!
  definitionType: TypeDefinitionType!
}

type LearnOpportunityChildStructureDefinition implements LearnOpportunityStructureDefinition {
  title: String!
  definitionType: StructureType!
}

interface LearnOpportunityContentTypeDefinition {
  contentNodeAdvancementResult: ContentNodeAdvancementResult!
  contentKind: ContentKind!
  extension: LearnContentExtension!
  definitionType: TypeDefinitionType!
}

type LearnOpportunityELearningContentTypeDefinition implements LearnOpportunityContentTypeDefinition & LearnOpportunityTypeDefinition {
  containedElementTypes: [ElementTypeV2!]!
  showAnswerElements: [ElementV2!]
  contentNodeAdvancementResult: ContentNodeAdvancementResult!
  contentKind: ContentKind!
  extension: LearnContentExtension!
  definitionType: TypeDefinitionType!
}

interface LearnOpportunityRootExtension {
  doNotUse: String!
}

type LearnOpportunityRootStructureDefinition implements LearnOpportunityStructureDefinition {
  extension: LearnOpportunityRootExtension!
  icon: File
  progressPercentage: Int
  tags: [Tag!]!
  viewerTreeState: ViewerTreeState!
  title: String!
  definitionType: StructureType!
}

interface LearnOpportunityStructureDefinition {
  title: String!
  definitionType: StructureType!
}

interface LearnOpportunityTypeDefinition {
  definitionType: TypeDefinitionType!
}

type LearnOpportunityV2 implements Node {
  """The ID of an object"""
  id: ID!
  attachmentsV2: [AttachmentV2!]!
  description: String
  image: File
  instructors: [Instructor!]!
  instructorsV2(before: String, after: String, first: Int, last: Int): InstructorsConnection!
  path: [LearnOpportunityV2!]!
  indexPath: [Int!]!
  root: LearnOpportunityV2
  shortDescription: String
  structureDefinition: LearnOpportunityStructureDefinition!
  lengthInSecondsV2: Int!
  nextContentNodeId: ID
  previousContentNodeId: ID
  nextContentNode: LearnOpportunityV2
  typeDefinition: LearnOpportunityTypeDefinition!
}

type LearnQueries {
  Tags(before: String, after: String, first: Int, last: Int): TagsConnection!
}

"""Data only accessible by the admin"""
type LearnV2AdminMutationSchema {
  deleteTree(input: DeleteTreeInput!): DeleteTreePayload
}

"""Data only accessible by the admin"""
type LearnV2AdminSchema {
  SearchLearnOpportunityV2(before: String, after: String, first: Int, last: Int, titleMatchRegex: String): LearnOpportunitiesV2Connection!
  GetTreeStates(before: String, after: String, first: Int, last: Int, filterByRootNodeId: ID, filterByUserId: ID): TreeStatesConnection!
  GetContentSubmissions(before: String, after: String, first: Int, last: Int, treeStateId: ID!): ContentSubmissionsConnection!
}

type LearnV2Mutations {
  submitMatrixElement(input: SubmitMatrixElementV2Input!): SubmitMatrixElementV2Payload
  submitMultipleChoiceElement(input: SubmitMultipleChoiceElementV2Input!): SubmitMultipleChoiceElementV2Payload
  submitDisplayElement(input: SubmitDisplayElementInput!): SubmitDisplayElementPayload
  submitClozeTextElement(input: SubmitClozeTextElementV2Input!): SubmitClozeTextElementV2Payload
  submitMarkMistakesElement(input: SubmitMarkMistakesElementV2Input!): SubmitMarkMistakesElementV2Payload
  startTree(input: StartTreeInput!): StartTreePayload
  startContentNode(input: StartContentNodeInput!): StartContentNodePayload
  restartContentNodeAfterPassed(input: RestartContentNodeAfterPassedInput!): RestartContentNodeAfterPassedPayload
  restartContentNodeAfterFailed(input: RestartContentNodeAfterFailedInput!): RestartContentNodeAfterFailedPayload
  submitOrderElement(input: SubmitOrderElementInput!): SubmitOrderElementPayload
}

"""Data partaining to the current user"""
type LearnViewerSchema {
  getActiveContentNodeOrFallbackRoot: GetActiveContentNodeOrFallbackRoot_Result!
  getActiveRoots: [LearnOpportunityV2!]!
  myNodeDocuments: [File!]!
}

input LeaveAccountInput {
  id: ID!
  clientMutationId: String
}

type LeaveAccountPayload {
  clientMutationId: String
}

input LeaveFeedbackInput {
  availabilityId: ID!
  feedbackData: FeedbackData!
  clientMutationId: String
}

type LeaveFeedbackPayload {
  availability: Availability!
  clientMutationId: String
}

type License {
  """The ID of an object"""
  id: ID!
  creationInfo: LicenseCreationInfo!
  usage: LicenseUsage!
}

interface LicenseAvailability {
  kind: LicenseAvailabilityKind!
}

type LicenseAvailabilityFreeLicensesAvailable implements LicenseAvailability {
  numAvailable: Int!
  kind: LicenseAvailabilityKind!
}

enum LicenseAvailabilityKind {
  FreeLicensesAvailable
  NoneAvailable
}

type LicenseAvailabilityNoneAvailableType implements LicenseAvailability {
  kind: LicenseAvailabilityKind!
}

"""A connection to a list of items."""
type LicenseConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [LicenseEdge]
}

type LicenseCreatedByAdmin implements LicenseCreationInfo {
  creatorId: ID!
  createdAt: ZonedDateTIme!
  licenseDefinition: LicenseDefinition
  kind: LicenseCreationInfoKind!
}

type LicenseCreatedByOrder implements LicenseCreationInfo {
  orderId: ID!
  createdAt: ZonedDateTIme!
  licenseDefinition: LicenseDefinition
  kind: LicenseCreationInfoKind!
}

type LicenseCreatedByPlacement implements LicenseCreationInfo {
  createdAt: ZonedDateTIme!
  licenseDefinition: LicenseDefinition
  kind: LicenseCreationInfoKind!
}

type LicenseCreatedByPotentialAnalysis implements LicenseCreationInfo {
  fromUserId: ID!
  createdAt: ZonedDateTIme!
  licenseDefinition: LicenseDefinition
  kind: LicenseCreationInfoKind!
}

type LicenseCreatedByRegistration implements LicenseCreationInfo {
  userId: ID!
  createdAt: ZonedDateTIme!
  licenseDefinition: LicenseDefinition
  kind: LicenseCreationInfoKind!
}

interface LicenseCreationInfo {
  createdAt: ZonedDateTIme!
  licenseDefinition: LicenseDefinition
  kind: LicenseCreationInfoKind!
}

enum LicenseCreationInfoKind {
  Admin
  Placement
  Order
  Registration
  PotentialAnalysis
}

type LicenseDefinition implements Node {
  """The ID of an object"""
  id: ID!
  data: LicenseDefinitionData!
}

"""Data only accessible by the admin"""
type LicenseDefinitionAdminMutationSchema {
  deleteLicenseDefinition(input: DeleteLicenseDefinitionInput!): DeleteLicenseDefinitionPayload
  createAVGSPotentialAnalysisLicenseDefinition(input: CreateAVGSPotentialAnalysisLicenseDefinitionInput!): CreateAVGSPotentialAnalysisLicenseDefinitionPayload
  editAVGSPotentialAnalysisLicenseDefinitionAdminMutation(input: EditAVGSPotentialAnalysisLicenseDefinitionAdminMutationInput!): EditAVGSPotentialAnalysisLicenseDefinitionAdminMutationPayload
  createCoachingLicenseDefinition(input: CreateCoachingLicenseDefinitionInput!): CreateCoachingLicenseDefinitionPayload
  editCoachingLicenseDefinitionAdminMutation(input: EditCoachingLicenseDefinitionAdminMutationInput!): EditCoachingLicenseDefinitionAdminMutationPayload
  createTreeLicenseDefinition(input: CreateTreeLicenseDefinitionInput!): CreateTreeLicenseDefinitionPayload
  editTreeLicenseDefinitionAdminMutation(input: EditTreeLicenseDefinitionAdminMutationInput!): EditTreeLicenseDefinitionAdminMutationPayload
  createMicroLearningLicenseDefinition(input: CreateMicroLearningLicenseDefinitionInput!): CreateMicroLearningLicenseDefinitionPayload
  editMicroLicenseDefinitionAdminMutation(input: EditMicroLearningLicenseDefinitionAdminMutationInput!): EditMicroLearningLicenseDefinitionAdminMutationPayload
}

"""Data only accessible by the admin"""
type LicenseDefinitionAdminSchema {
  SearchLicenseDefinitions(before: String, after: String, first: Int, last: Int, nameMatchRegex: String, dataKinds: [LicenseDefinitionDataKind!]!): LicenseDefinitionsConnection!
}

type LicenseDefinitionCoachingInfo {
  coachingId: ID!
  title: String!
  image: File
  contractPartner: ContractPartner
}

interface LicenseDefinitionData {
  name: String!
  kind: LicenseDefinitionDataKind!
}

enum LicenseDefinitionDataKind {
  AVGSPotentialAnalysis
  Coaching
  Tree
  MicroLearning
}

type LicenseDefinitionRootInfo {
  rootId: ID!
  title: String!
  image: File
  contractPartner: ContractPartner
}

"""A connection to a list of items."""
type LicenseDefinitionsConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [LicenseDefinitionsEdge]
}

"""An edge in a connection."""
type LicenseDefinitionsEdge {
  """The item at the end of the edge."""
  node: LicenseDefinition!

  """A cursor for use in pagination."""
  cursor: String!
}

"""An edge in a connection."""
type LicenseEdge {
  """The item at the end of the edge."""
  node: License!

  """A cursor for use in pagination."""
  cursor: String!
}

interface LicenseGrouping {
  id: ID!
  totalLicenseAmount: Int!
  usedLicenseAmount: Int!
  totalLicenseAmountForUser: Int!
  usedLicenseAmountForUser: Int!
  assignmentRules: [AssignmentRule!]!
  kind: LicenseGroupingKind!
}

enum LicenseGroupingKind {
  MicroLearning
  Learnable
}

type LicenseGroupingQueries {
  MyLicenses(before: String, after: String, first: Int, last: Int, text: String, kinds: [LearnableKind!]!, licensesAvailable: Boolean, licensesConsumed: Boolean): LicenseGroupingsConnection!
  LicenseGroupings(before: String, after: String, first: Int, last: Int, text: String, kinds: [LearnableKind!]!, licensesAvailable: Boolean, licensesConsumed: Boolean): LicenseGroupingsConnection!
  LicenseGrouping(id: ID!): LicenseGrouping!
}

"""A connection to a list of items."""
type LicenseGroupingsConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [LicenseGroupingsEdge]
}

"""An edge in a connection."""
type LicenseGroupingsEdge {
  """The item at the end of the edge."""
  node: LicenseGrouping!

  """A cursor for use in pagination."""
  cursor: String!
}

type LicenseManagementMutations {
  createSingleUserAssignmentRule(input: CreateSingleUserAssignmentRuleInput!): CreateSingleUserAssignmentRulePayload
  editSingleUserAssignmentRule(input: EditSingleUserAssignmentRuleInput!): EditSingleUserAssignmentRulePayload
  createAccountGroupAssignmentRule(input: CreateAccountGroupAssignmentRuleInput!): CreateAccountGroupAssignmentRulePayload
  editAccountGroupAssignmentRule(input: EditAccountGroupAssignmentRuleInput!): EditAccountGroupAssignmentRulePayload
  deleteAssignmentRule(input: DeleteAssignmentRuleInput!): DeleteAssignmentRulePayload
}

type LicenseModelMutations {
  editLicenseModel(input: EditLicenseModelInput!): EditLicenseModelPayload
}

type LicenseProduct implements Product & Node {
  isTaxFree: Boolean!
  netPrice: BigDecimal!
  chGrossPrice: BigDecimal!
  atGrossPrice: BigDecimal!
  deGrossPrice: BigDecimal!
  licenseDefinition: LicenseDefinition
  licenseDefinitionAmount: Int
  costUnit: String
  id: ID!
  title: String!
  price: Price!
  isHidden: Boolean!
  productType: String!
}

type LicensesGroupedByDefinition {
  definition: LicenseDefinition
  numUsed: Int!
  numFree: Int!
  usedBy: [User!]!
}

"""A connection to a list of items."""
type LicensesGroupedByDefinitionConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [LicensesGroupedByDefinitionEdge]
}

"""An edge in a connection."""
type LicensesGroupedByDefinitionEdge {
  """The item at the end of the edge."""
  node: LicensesGroupedByDefinition!

  """A cursor for use in pagination."""
  cursor: String!
}

interface LicenseUsage {
  kind: LicenseUsageKind!
}

type LicenseUsageFree implements LicenseUsage {
  kind: LicenseUsageKind!
}

enum LicenseUsageKind {
  UsedForCoaching
  Free
  UsedForAVGSPotentialAnalysis
  UsedForTree
}

type LicenseUsageUsedForCoaching implements LicenseUsed & LicenseUsage {
  at: ZonedDateTIme!
  forUser: User
  kind: LicenseUsageKind!
}

type LicenseUsageUsedForTree implements LicenseUsed & LicenseUsage {
  at: ZonedDateTIme!
  forUser: User
  kind: LicenseUsageKind!
}

interface LicenseUsed {
  at: ZonedDateTIme!
  forUser: User
  kind: LicenseUsageKind!
}

type LicenseUsedForCreatingAVGSPotentialAnalysis implements LicenseUsed & LicenseUsage {
  at: ZonedDateTIme!
  forUser: User
  kind: LicenseUsageKind!
}

type LimitedCartDiscount implements Node {
  """The ID of an object"""
  id: ID!
  title: String!
  createdAt: ZonedDateTIme!
  conditions: [LimitedCartDiscountCondition!]!
  productSelectionConfig: ProductSelectionConfig!
}

interface LimitedCartDiscountCondition {
  """The ID of an object"""
  id: ID!
  kind: LimitedCartDiscountConditionKindEnum!
}

enum LimitedCartDiscountConditionKindEnum {
  ProductSelectionCondition
}

"""A connection to a list of items."""
type LimitedCartDiscountConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [LimitedCartDiscountEdge]
}

"""An edge in a connection."""
type LimitedCartDiscountEdge {
  """The item at the end of the edge."""
  node: LimitedCartDiscount!

  """A cursor for use in pagination."""
  cursor: String!
}

scalar LocalDate

scalar LocalTime

input LoginAsUserJwtInput {
  userId: ID!
  clientMutationId: String
}

type LoginAsUserJwtPayload {
  jwtTokens: JwtLoginInformation!
  clientMutationId: String
}

input LoginInput {
  email: String!
  password: String!
  clientMutationId: String
}

input LoginJwtInput {
  email: String!
  password: String!
  clientMutationId: String
}

type LoginJwtPayload {
  loginResult: LoginResult!
  clientMutationId: String
}

type LoginPayload {
  token: String!
  accounts: [Account!]!
  permissionsInAccounts: [AccountPermissions!]!
  groupAssociations: [UserGroupAssociation!]!
  userId: ID!
  clientMutationId: String
}

type LoginResult {
  jwtTokens: JwtLoginInformation!
  firstLogin: Boolean!
  extension: LoginResultExtension!
}

interface LoginResultExtension {
  doNotUse: String!
}

input LogoutJwtInput {
  clientMutationId: String
}

type LogoutJwtPayload {
  clientMutationId: String
}

"""
The `Long` scalar type represents non-fractional signed whole numeric values.
Long can represent values between -(2^63) and 2^63 - 1.
"""
scalar Long

"""Data only accessible by the admin"""
type ManagementAdminSchema {
  UsersAdmin(before: String, after: String, first: Int, last: Int, filterByName: String, excludeIds: [ID!], alwaysIncludeIds: [ID!]): UserConnection!
  AccountGroups(before: String, after: String, first: Int, last: Int): AccountGroupsConnection!
}

type ManagementQueries {
  Groups(before: String, after: String, first: Int, last: Int): UserInAccountGroupsConnection!
}

type MandateInformation {
  acceptanceDateTime: ZonedDateTIme!
  mandateNumber: String!
}

type MarkMistakes_Snippet {
  content: String!
}

type MarkMistakesElement implements ElementV2 {
  text: String!

  """The ID of an object"""
  id: ID!
  title: String!
  elementType: ElementTypeV2!
  extension: ElementExtension!
}

type MarkMistakesInputElementState implements InputElementState & ElementState {
  checkedMistakeIndices: [Int!]!
  element: LearnElement!
  kind: ElementStateKind!
}

type MarkMistakesLearnElement implements LearnElement {
  snippets: [MarkMistakes_Snippet!]!

  """The ID of an object"""
  id: ID!
  title: String!
  elementType: ElementTypeV2!
}

type MarkMistakesShowAnswerElementState implements ShowAnswerElementState & ElementState {
  correctMistakeIndices: [Int!]!
  lastCheckedMistakeIndices: [Int!]
  element: LearnElement!
  kind: ElementStateKind!
}

type MatrixElement implements ElementV2 {
  cells: [MatrixElementCell!]!

  """The ID of an object"""
  id: ID!
  title: String!
  elementType: ElementTypeV2!
  extension: ElementExtension!
}

interface MatrixElementCell {
  """The ID of an object"""
  id: ID!
  xIdx: Int!
  yIdx: Int!
  kind: MatrixElementCellKind!
}

interface MatrixElementCellAnswer {
  content: String!
  isCorrect: Boolean!
}

type MatrixElementCellCorrectAnswer implements MatrixElementCellAnswer {
  content: String!
  isCorrect: Boolean!
}

enum MatrixElementCellKind {
  Display
  Answer
}

type MatrixElementCellWrongAnswer implements MatrixElementCellAnswer {
  """The ID of an object"""
  id: ID!
  content: String!
  isCorrect: Boolean!
}

type MatrixInputElementState implements InputElementState & ElementState {
  checkedIndices: [MatrixLearnElementIndexCell!]!
  element: LearnElement!
  kind: ElementStateKind!
}

type MatrixLearnElement implements LearnElement {
  cells: [MatrixLearnElementCell!]!

  """The ID of an object"""
  id: ID!
  title: String!
  elementType: ElementTypeV2!
}

type MatrixLearnElementAnswer {
  content: String!
}

interface MatrixLearnElementCell {
  xIdx: Int!
  yIdx: Int!
  kind: MatrixElementCellKind!
}

type MatrixLearnElementIndexCell {
  xIdx: Int!
  yIdx: Int!
  index: Int!
}

type MatrixShowAnswerElementState implements ShowAnswerElementState & ElementState {
  correctIndices: [MatrixLearnElementIndexCell!]!
  lastCheckedIndices: [MatrixLearnElementIndexCell!]
  element: LearnElement!
  kind: ElementStateKind!
}

type MicroLearningLicenseDefinitionData implements LicenseDefinitionData {
  name: String!
  kind: LicenseDefinitionDataKind!
}

input MicroLearningLicenseDefinitionDataInput {
  name: String!
}

type MicroLearningLicenseGrouping implements LicenseGrouping {
  id: ID!
  totalLicenseAmount: Int!
  usedLicenseAmount: Int!
  totalLicenseAmountForUser: Int!
  usedLicenseAmountForUser: Int!
  assignmentRules: [AssignmentRule!]!
  kind: LicenseGroupingKind!
}

type MonthlyOption {
  rateCount: Int!
  totalAmount: Price!
  downPayment: Price!
  monthlyRate: Price!
  closingRate: Price!
  financedAmount: Price!
  paymentMethodTypes: [PaymentMethodType!]!
}

type MonthlySelectedPaymentMethod implements SelectedPaymentMethod {
  paymentMethodId: PaymentMethodType!
  selectedPaymentMethodType: SelectedPaymentMethodType!
  chosenOption: MonthlyOption!
}

input MoveChildNodeInput {
  childToBeMovedId: ID!
  newParentId: ID!
  newPreviousSiblingId: ID
  clientMutationId: String
}

type MoveChildNodePayload {
  tree: Tree!
  clientMutationId: String
}

input MoveOrderItemsInput {
  orderElementId: ID!
  orderItemIds: [ID!]!
  clientMutationId: String
}

type MoveOrderItemsPayload {
  orderElement: OrderElement!
  clientMutationId: String
}

type MultipleChoiceElementV2 implements ElementV2 {
  question: String!
  answeringType: AnsweringTypeV2!
  answeringTypeText: String
  image: File
  answerOptions: [AnswerOptionV2!]!

  """The ID of an object"""
  id: ID!
  title: String!
  elementType: ElementTypeV2!
  extension: ElementExtension!
}

type MultipleChoiceInputElementState implements InputElementState & ElementState {
  checkedAnswerIndices: [Int!]!
  element: LearnElement!
  kind: ElementStateKind!
}

type MultipleChoiceLearnElement implements LearnElement {
  question: String!
  answeringType: AnsweringTypeV2!
  answeringTypeText: String
  image: File
  answerOptions: [AnswerOptionWithoutCorrect!]!

  """The ID of an object"""
  id: ID!
  title: String!
  elementType: ElementTypeV2!
}

type MultipleChoiceShowAnswerElementState implements ShowAnswerElementState & ElementState {
  correctAnswerIndices: [Int!]!
  lastCheckedAnswerIndices: [Int!]
  element: LearnElement!
  kind: ElementStateKind!
}

type Mutation {
  Learn: LearnMutations!
  Auth: AuthMutations!
  Notification: NotificationMutations!
  PotentialAnalysis: PotentialAnalysisMutations!
  ELearning: ELearningMutations!
  Reports: ReportsMutations!
  AvgsPotentialAnalysis: AvgsPotentialAnalysisMutations!
  AccountMemberManagement: AccountMemberManagementMutations!
  LicenseModel: LicenseModelMutations!
  AsyncContent: AsyncContentMutations!
  AccountBaseData: AccountBaseDataMutations!
  Billing: BillingMutations!
  LicenseManagement: LicenseManagementMutations!
  Coaching: CoachingMutations!
  LearnV2: LearnV2Mutations!
  Vocab: VocabMutations!
  Placement: PlacementMutations!

  """Data partaining to the current user"""
  Viewer: ViewerMutationType!

  """Data only accessible by the admin"""
  Admin: AdminMutationType!
}

type NegativeBlockPermanentlyRestartIfFailedContentConfigResult implements NegativeRestartIfFailedContentConfigResult & RestartIfFailedContentConfigResult {
  canBeRestarted: Boolean!
  configType: RestartIfFailedContentConfigType!
}

type NegativeBlockTemporarilyRestartIfFailedContentConfigResult implements NegativeRestartIfFailedContentConfigResult & RestartIfFailedContentConfigResult {
  blockedUntil: ZonedDateTIme!
  canBeRestarted: Boolean!
  configType: RestartIfFailedContentConfigType!
}

type NegativeCanNotRestartIfFailedContentConfigResult implements NegativeRestartIfFailedContentConfigResult & RestartIfFailedContentConfigResult {
  canBeRestarted: Boolean!
  configType: RestartIfFailedContentConfigType!
}

interface NegativeRestartIfFailedContentConfigResult {
  canBeRestarted: Boolean!
  configType: RestartIfFailedContentConfigType!
}

"""An object with an ID"""
interface Node {
  """The id of the object."""
  id: ID!
}

type NoPodcastSourceV2 implements PodcastSourceV2 {
  sourceType: PodcastSourceTypeV2!
}

type NotAfterDateTimeVisibilityTreeConfig implements VisibilityTreeConfig {
  dateTime: ZonedDateTIme!

  """The ID of an object"""
  id: ID!
  configType: VisibilityTreeConfigType!
}

type NotBooked implements BookingInterface {
  kind: BookingKind!
}

type NotContentNodeContentNodeAdvancementResult implements ContentNodeAdvancementResult {
  status: ContentNodeAdvancementStatus!
}

"""Data only accessible by the admin"""
type NotificationAdminMutationSchema {
  createPersonalizedNotificationTemplate(input: CreatePersonalizedNotificationTemplateInput!): CreatePersonalizedNotificationTemplatePayload
  updatePersonalizedNotificationTemplate(input: UpdatePersonalizedNotificationTemplateInput!): UpdatePersonalizedNotificationTemplatePayload
  deletePersonalizedNotificationTemplate(input: DeletePersonalizedNotificationTemplateInput!): DeletePersonalizedNotificationTemplatePayload
}

"""Data only accessible by the admin"""
type NotificationAdminSchema {
  AvailableSystemTemplates(before: String, after: String, first: Int, last: Int): [NotificationTemplate!]!
  PersonalizedNotificationTemplates(before: String, after: String, first: Int, last: Int): PersonalizedNotificationTemplatesConnection!
}

type NotificationMutations {
  registerForNotification(input: RegisterForNotificationInput!): RegisterForNotificationPayload
}

enum NotificationServiceType {
  Apns
  Gcm
}

type NotificationTemplate {
  key: String!
  title: String!
  message: String!
  variables: [String!]!
}

type NotVisibleViewerTreeState implements ViewerTreeState {
  reasonConfigTypes: [VisibilityTreeConfigType!]!
  kind: ViewerTreeStateKind!
}

type OneTimeSelectedPaymentMethod implements SelectedPaymentMethod {
  selectedPaymentMethodType: SelectedPaymentMethodType!
  paymentMethodId: PaymentMethodType!
  stripeData: StripeData
}

type OneToOneCoachingSetting implements CoachingSetting {
  kind: CoachingSettingKind!
}

type OnlyAdminsVisibilityTreeConfig implements VisibilityTreeConfig {
  """The ID of an object"""
  id: ID!
  configType: VisibilityTreeConfigType!
}

type OnlyAZAVAccountVisibilityCoachingConfig implements VisibilityCoachingConfig {
  """The ID of an object"""
  id: ID!
  configType: VisibilityCoachingConfigType!
}

type OnlyAZAVAccountVisibilityTreeConfig implements VisibilityTreeConfig {
  """The ID of an object"""
  id: ID!
  configType: VisibilityTreeConfigType!
}

type OnlyBusinessAccountVisibilityCoachingConfig implements VisibilityCoachingConfig {
  """The ID of an object"""
  id: ID!
  configType: VisibilityCoachingConfigType!
}

type OnlyBusinessAccountVisibilityTreeConfig implements VisibilityTreeConfig {
  """The ID of an object"""
  id: ID!
  configType: VisibilityTreeConfigType!
}

type OnlyEditorsVisibilityTreeConfig implements VisibilityTreeConfig {
  """The ID of an object"""
  id: ID!
  configType: VisibilityTreeConfigType!
}

type OnlyIfTreeStateVisibilityTreeConfig implements VisibilityTreeConfig {
  """The ID of an object"""
  id: ID!
  configType: VisibilityTreeConfigType!
}

type OnlyPermissionsImplVisibilityTreeConfig implements VisibilityTreeConfig {
  """The ID of an object"""
  id: ID!
  configType: VisibilityTreeConfigType!
}

type OnlyWithLicenseVisibilityCoachingConfig implements VisibilityCoachingConfig {
  """The ID of an object"""
  id: ID!
  configType: VisibilityCoachingConfigType!
}

type Order implements Node {
  """The ID of an object"""
  id: ID!
  history(before: String, after: String, first: Int, last: Int): OrderHistoriesConnection!
  billingDetails: BillingDetails
  cart: Cart
  invoiceData: InvoiceData
  creditNoteData: CreditNoteData
  paymentData: PaymentProviderData
  purchaser: Purchaser
  allowedPaymentMethods: [PaymentMethodType!]!
  selectedPaymentMethod: SelectedPaymentMethod
  selectedPaymentDate: ZonedDateTIme
  status: OrderStatus!
  createdAt: ZonedDateTIme!
}

type OrderCreationUpdate implements HistoryEventInterface {
  kind: HistoryEventType!
}

type OrderElement implements ElementV2 {
  orderItems: [OrderItem!]!
  answeringTypeText: String

  """The ID of an object"""
  id: ID!
  title: String!
  elementType: ElementTypeV2!
  extension: ElementExtension!
}

"""A connection to a list of items."""
type OrderHistoriesConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [OrderHistoriesEdge]
}

"""An edge in a connection."""
type OrderHistoriesEdge {
  """The item at the end of the edge."""
  node: OrderHistory!

  """A cursor for use in pagination."""
  cursor: String!
}

type OrderHistory {
  """The ID of an object"""
  id: ID!
  orderId: ID!
  createdAt: ZonedDateTIme!
  event: HistoryEventInterface!
  status: OrderStatus!
}

input OrderIHKCertificateInput {
  userData: IHKCertificateOrderUserDataInput!
  rootId: ID!
  clientMutationId: String
}

type OrderIHKCertificatePayload {
  root: LearnOpportunityV2!
  clientMutationId: String
}

type OrderInputElementState implements InputElementState & ElementState {
  selectedOrder: [ID!]!
  element: LearnElement!
  kind: ElementStateKind!
}

type OrderItem {
  """The ID of an object"""
  id: ID!
  text: String!
}

type OrderLearnElement implements LearnElement {
  orderItems: [OrderItem!]!
  answeringTypeText: String

  """The ID of an object"""
  id: ID!
  title: String!
  elementType: ElementTypeV2!
}

"""A connection to a list of items."""
type OrdersConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [OrdersEdge]
}

"""An edge in a connection."""
type OrdersEdge {
  """The item at the end of the edge."""
  node: Order!

  """A cursor for use in pagination."""
  cursor: String!
}

type OrderShowAnswerElementState implements ShowAnswerElementState & ElementState {
  correctOrder: [ID!]!
  lastSelectedOrder: [ID!]!
  element: LearnElement!
  kind: ElementStateKind!
}

enum OrderStatus {
  HasPaymentDetails
  HasBillingDetails
  PaymentReceived
  Purchased
  Transient
  HasCart
}

type PackageUnlock {
  wordPackage: WordPackage
  unlockedAt: ZonedDateTIme!
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type Participant {
  user: User
  participationStatus: ParticipationStatus!
}

type ParticipationCertificate {
  name: String!
  html: String!
  variables: [String!]!
}

type ParticipationCertificate_ErrorOccurredRewardResult implements RewardResult {
  rewardId: ID!
  rewardKind: RewardKind!
  kind: RewardResultKind!
}

type ParticipationCertificate_NotPassedRewardResult implements RewardResult {
  rewardId: ID!
  rewardKind: RewardKind!
  kind: RewardResultKind!
}

type ParticipationCertificate_ParticipationCertificateRewardResult implements RewardResult {
  data: ParticipationCertificate_ParticipationCertificateRewardResultData!
  rewardId: ID!
  rewardKind: RewardKind!
  kind: RewardResultKind!
}

type ParticipationCertificate_ParticipationCertificateRewardResultData {
  name: String!
  file: File
}

type ParticipationCertificateReward implements Reward {
  data: ParticipationCertificateRewardData!

  """The ID of an object"""
  id: ID!
  superId: ID!
  kind: RewardKind!
}

type ParticipationCertificateRewardData {
  name: String!
  html: String!
  variables: [ParticipationCertificateRewardVariables!]!
}

input ParticipationCertificateRewardDataInput {
  name: String!
  html: String!
  variables: [ParticipationCertificateRewardDataVariableInput!]!
}

input ParticipationCertificateRewardDataVariableInput {
  key: ParticipationCertificateRewardVariables!
  value: String!
}

enum ParticipationCertificateRewardVariables {
  certificationName
  description
  shortDesc
  firstName
  lastName
  partnerName
  submissionDate
}

enum ParticipationStatus {
  NotConfirmed
  Participated
  AbsentExcused
  Absent
}

interface PassContentConfig {
  """The ID of an object"""
  id: ID!
  configType: PassContentConfigType!
}

enum PassContentConfigType {
  PassContent_Always
  PassContent_IHKFlow
}

type PassedAsyncContentSubmissionDefinition implements FinishedAsyncContentSubmissionDefinitionInterface & AsyncContentSubmissionDefinition & ContentSubmissionDefinition {
  rewardResults: [RewardResult!]!
  element: AsyncLearnElement
  status: ContentSubmissionStatus!
  contentKind: ContentKind!
}

type PassedELearningContentSubmissionDefinition implements FinishedELearningContentSubmissionDefinitionInterface & ELearningContentSubmissionDefinition & ContentSubmissionDefinition {
  rewardResults: [RewardResult!]!
  progress: ELearningContentSubmissionProgress!
  relativeProgress: ELearningContentSubmissionRelativeProgress!
  status: ContentSubmissionStatus!
  contentKind: ContentKind!
}

type PaymentInProcessUpdate implements HistoryEventInterface {
  kind: HistoryEventType!
}

enum PaymentMethodType {
  Card
  Sepa
  Sofort
  Paypal
  Giropay
  InvoiceTk
  MonthlyTk
  InvoicePartner
  MonthlyPartner
  IapGoogle
  IapApple
  Klarna
}

type PaymentMethodUpdate implements HistoryEventInterface {
  kind: HistoryEventType!
}

interface PaymentProviderData {
  paymentMethod: PaymentMethodType!
  dataType: PaymentProviderDataType!
}

enum PaymentProviderDataType {
  Sepa
  Stripe
  StripeSepa
  AppleIap
  GoogleIap
  Default
}

enum PaymentType {
  OneTimePayment
  MonthlyPayment
  EmployerInvoice
}

input PayOrderInput {
  iban: String
  orderId: ID!
  clientMutationId: String
}

type PayOrderPayload {
  order: Order!
  clientMutationId: String
}

input PayOrderViaIAPInput {
  receipt: String!
  orderId: ID!
  targetSystem: TargetSystem!
  clientMutationId: String
}

type PayOrderViaIAPPayload {
  order: Order!
  clientMutationId: String
}

type PercentageProductSelectionConfig implements ProductSelectionConfig {
  value: Int!
  kind: ProductSelectionConfigKindEnum!
}

enum Permission {
  UserInAccountPermission_ContractPartnerAdmin_Read
  UserInAccountPermission_ContractPartnerAdmin_Modify
  UserInAccountPermission_OrderAdmin_Read
  UserInAccountPermission_OrderAdmin_Modify
  UserInAccountPermission_DiscountAdmin_Read
  UserInAccountPermission_DiscountAdmin_Modify
  UserInAccountPermission_LimitedCartDiscountAdmin_Read
  UserInAccountPermission_LimitedCartDiscountAdmin_Modify
  UserInAccountPermission_GenerateCartLinkAdmin_Modify
  UserInAccountPermission_CachingAdmin_Modify
  UserInAccountPermission_VocabAdmin_ReadWordPackages
  UserInAccountPermission_VocabAdmin_ModifyWordPackages
  UserInAccountPermission_CoachBillingAdmin_Read
  UserInAccountPermission_LearnableAdmin_Read
  UserInAccountPermission_LearnableAdmin_Modify
  UserInAccountPermission_Tags_CreateTags
  UserInAccountPermission_Tags_ReadTags
  UserInAccountPermission_Tags_UpdateTags
  UserInAccountPermission_Tags_DeleteTags
  UserInAccountPermission_Email_Templates
  UserInAccountPermission_LicenseDefinitionAdmin_Read
  UserInAccountPermission_LicenseDefinitionAdmin_Modify
  UserInAccountPermission_Auth_Read
  UserInAccountPermission_Auth_Modify
  UserInAccountPermission_AuthAdmin_Read
  UserInAccountPermission_AuthAdmin_Modify
  UserInAccountPermission_AuthAdmin_MinimalRead
  UserInAccountPermission_CustomerFeedback_Read
  UserInAccountPermission_CustomerFeedback_Modify
  UserInAccountPermission_Management_Management
  UserInAccountPermission_TagAdmin_Read
  UserInAccountPermission_TagAdmin_Modify
  UserInAccountPermission_TagAdmin_Select
  UserInAccountPermission_CoachingCoachProfileAdmin_ReadCoachProfiles
  UserInAccountPermission_CoachingCoachProfileAdmin_ModifyCoachProfiles
  UserInAccountPermission_AVGSPotentialAnalysis_ReadAdmin
  UserInAccountPermission_AVGSPotentialAnalysis_ModifyAdmin
  UserInAccountPermission_AVGSPotentialAnalysis_IsAVGSCoach
  UserInAccountPermission_AVGSPotentialAnalysis_IsAVGSAdmin
  UserInAccountPermission_Trend_Read
  UserInAccountPermission_Trend_Modify
  UserInAccountPermission_CoachingAvailabilityAdmin_ReadAvailability
  UserInAccountPermission_CoachingAvailabilityAdmin_ModifyAvailability
  UserInAccountPermission_SettingsAdmin_Read
  UserInAccountPermission_SettingsAdmin_Modify
  UserInAccountPermission_AZAVAdmin_Read
  UserInAccountPermission_AZAVAdmin_Modify
  UserInAccountPermission_FeatureToggleAdmin_Read
  UserInAccountPermission_FeatureToggleAdmin_Modify
  UserInAccountPermission_ReportAdmin_Read
  UserInAccountPermission_ReportAdmin_Modify
  UserInAccountPermission_Files_Delete
  UserInAccountPermission_Instructors_CreateInstructors
  UserInAccountPermission_Instructors_ReadInstructors
  UserInAccountPermission_Instructors_UpdateInstructors
  UserInAccountPermission_Instructors_DeleteInstructors
  UserInAccountPermission_PlacementContactPerson_Access
  UserInAccountPermission_Nodes_CreateNodes
  UserInAccountPermission_Nodes_ReadNodes
  UserInAccountPermission_Nodes_UpdateNodes
  UserInAccountPermission_Nodes_DeleteNodes
  UserInAccountPermission_Nodes_PublishNodes
  UserInAccountPermission_AsyncElementTaskAdmin_Read
  UserInAccountPermission_AsyncElementTaskAdmin_Modify
  UserInAccountPermission_ExternalLicenseAdmin_Read
  UserInAccountPermission_ExternalLicenseAdmin_Modify
  UserInAccountPermission_LicenseAdmin_Read
  UserInAccountPermission_LicenseAdmin_Modify
  UserInAccountPermission_LearnStates_ReadLearnStates
  UserInAccountPermission_Submissions_ReadSubmissions
  UserInAccountPermission_CoachingOfferAdmin_Read
  UserInAccountPermission_CoachingOfferAdmin_Modify
  UserInAccountPermission_CoachFeedback_Read
  UserInAccountPermission_ProductAdmin_Read
  UserInAccountPermission_ProductAdmin_Modify
  UserInAccountPermission_System_Owner
  AccountPermission_AccountMemberManagement_CanInviteOrAddUsersToUserInAccountGroups
  AccountPermission_Auth_IsBusinessAccount
  AccountPermission_Auth_usePlacement
  AccountPermission_CoachingCoachProfileAdmin_IsCoachAccount
  AccountPermission_AVGSPotentialAnalysis_IsAVGSAccount
  AccountPermission_AZAVAdmin_IsAZAVAccount
  AccountPermission_System_Root
}

type PersonalizedEmailTemplate implements Node {
  """The ID of an object"""
  id: ID!
  template: EmailTemplate!
}

input PersonalizedEmailTemplateInput {
  key: String!
  subject: String!
  previewText: String!
  body: String!
  variables: [String!]!
}

"""A connection to a list of items."""
type PersonalizedEmailTemplatesConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [PersonalizedEmailTemplatesEdge]
}

"""An edge in a connection."""
type PersonalizedEmailTemplatesEdge {
  """The item at the end of the edge."""
  node: PersonalizedEmailTemplate!

  """A cursor for use in pagination."""
  cursor: String!
}

type PersonalizedNotificationTemplate implements Node {
  """The ID of an object"""
  id: ID!
  template: NotificationTemplate!
}

input PersonalizedNotificationTemplateInput {
  key: String!
  title: String!
  message: String!
  variables: [String!]!
}

"""A connection to a list of items."""
type PersonalizedNotificationTemplatesConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [PersonalizedNotificationTemplatesEdge]
}

"""An edge in a connection."""
type PersonalizedNotificationTemplatesEdge {
  """The item at the end of the edge."""
  node: PersonalizedNotificationTemplate!

  """A cursor for use in pagination."""
  cursor: String!
}

type PingQueries {
  """A simple endpoint to find out if the API is reachable"""
  ping: String!
}

type PlacementMutations {
  grantPlacementPermissionAndRedirect(input: GrantPlacementPermissionAndRedirectInput!): GrantPlacementPermissionAndRedirectPayload
  createClickOutForUserOrBusiness(input: CreateClickOutForUserOrBusinessInput!): CreateClickOutForUserOrBusinessPayload
  createClickOutByLinkId(input: CreateClickOutByLinkIdInput!): CreateClickOutByLinkIdPayload
  addMatchingPlacement(input: AddMatchingPlacementInput!): AddMatchingPlacementPayload
  informAboutSuccessfulPlacement(input: InformAboutSuccessfulPlacementInput!): InformAboutSuccessfulPlacementPayload
  sendAskCompanyIfContractWasConcluded(input: SendAskCompanyIfContractWasConcludedInput!): SendAskCompanyIfContractWasConcludedPayload
  sendCompanyIsInterestedInUserProfile(input: SendCompanyIsInterestedInUserProfileInput!): SendCompanyIsInterestedInUserProfilePayload
  sendInformAboutAcceptedMatching(input: SendInformAboutAcceptedMatchingInput!): SendInformAboutAcceptedMatchingPayload
  sendInformAboutAvailableDossier(input: SendInformAboutAvailableDossierInput!): SendInformAboutAvailableDossierPayload
  sendMatchingResultsAvailableToBusiness(input: SendMatchingResultsAvailableToBusinessInput!): SendMatchingResultsAvailableToBusinessPayload
  sendMatchingResultsAvailableToUser(input: SendMatchingResultsAvailableToUserInput!): SendMatchingResultsAvailableToUserPayload
  sendRemindCompanyToPayFee(input: SendRemindCompanyToPayFeeInput!): SendRemindCompanyToPayFeePayload
  sendReminderForInviteToSecondInterview(input: SendReminderForInviteToSecondInterviewInput!): SendReminderForInviteToSecondInterviewPayload
  sendReminderForSecondInterviewToUser(input: SendReminderForSecondInterviewToUserInput!): SendReminderForSecondInterviewToUserPayload
  sendSummaryForFirstInterviewToContactPerson(input: SendSummaryForFirstInterviewToContactPersonInput!): SendSummaryForFirstInterviewToContactPersonPayload
  sendSummaryForFirstInterviewToUser(input: SendSummaryForFirstInterviewToUserInput!): SendSummaryForFirstInterviewToUserPayload
  sendSummaryForSecondInterviewToContactPerson(input: SendSummaryForSecondInterviewToContactPersonInput!): SendSummaryForSecondInterviewToContactPersonPayload
  sendSummaryForSecondInterviewToUser(input: SendSummaryForSecondInterviewToUserInput!): SendSummaryForSecondInterviewToUserPayload
  sendUserIsInterestedForJobListing(input: SendUserIsInterestedForJobListingInput!): SendUserIsInterestedForJobListingPayload
}

type PlacementProduct implements Product & Node {
  isTaxFree: Boolean!
  netPrice: BigDecimal!
  chGrossPrice: BigDecimal!
  atGrossPrice: BigDecimal!
  deGrossPrice: BigDecimal!
  costUnit: String
  id: ID!
  title: String!
  price: Price!
  isHidden: Boolean!
  productType: String!
}

type PlacementQueries {
  PlacementBusinessBaseData(before: String, after: String, first: Int, last: Int, accountId: ID!, userId: ID!): BusinessBaseDataOutput!
  permissionCartClickOut(before: String, after: String, first: Int, last: Int): String!
}

type PodcastElementV2 implements ElementV2 {
  podcastSource: PodcastSourceV2!
  durationInSeconds: Int
  releasedFileOpt: ReleasedFileV2
  releasedSubtitlesOpt: ReleasedSubtitlesV2

  """The ID of an object"""
  id: ID!
  title: String!
  elementType: ElementTypeV2!
  extension: ElementExtension!
}

type PodcastLearnElement implements LearnElement {
  podcastSource: PodcastSourceV2!
  durationInSeconds: Int
  releasedFileOpt: ReleasedFileV2
  releasedSubtitlesOpt: ReleasedSubtitlesV2

  """The ID of an object"""
  id: ID!
  title: String!
  elementType: ElementTypeV2!
}

enum PodcastSourceTypeV2 {
  vimeo
  podigee
  none
}

interface PodcastSourceV2 {
  sourceType: PodcastSourceTypeV2!
}

type PodcastWithTimestamp implements ElementV2 {
  title: String!
  podcastFile: File
  timestampsWithImage: [TimestampWithImage!]!

  """The ID of an object"""
  id: ID!
  elementType: ElementTypeV2!
  extension: ElementExtension!
}

type PodcastWithTimestampLearnElement implements LearnElement {
  title: String!
  podcastFile: File!
  timestampsWithImage: [TimestampWithImage!]!
  start: Int!
  end: Int!
  duration: Int!

  """The ID of an object"""
  id: ID!
  elementType: ElementTypeV2!
}

type PodigeePodcastSourceV2 implements PodcastSourceV2 {
  podigeeUrl: String!
  lengthInSeconds: Int!
  sourceType: PodcastSourceTypeV2!
}

type PositiveRestartIfFailedContentConfigResult implements RestartIfFailedContentConfigResult {
  canBeRestarted: Boolean!
  configType: RestartIfFailedContentConfigType!
}

interface PotentialAnalysisAnswerOption {
  answerOptionId: Int!
}

"""A connection to a list of items."""
type PotentialAnalysisConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [PotentialAnalysisEdge]
}

"""An edge in a connection."""
type PotentialAnalysisEdge {
  """The item at the end of the edge."""
  node: AVGSPotentialAnalysis_PotentialAnalysis!

  """A cursor for use in pagination."""
  cursor: String!
}

type PotentialAnalysisFreetextAnswerOption implements PotentialAnalysisAnswerOption {
  text: String!
  isFreeText: Boolean!
  answerOptionId: Int!
}

input PotentialAnalysisFreeTextAnswerOptionInput {
  answerOptionId: Int!
  text: String!
  isFreeText: Boolean!
}

interface PotentialAnalysisGivenAnswer {
  kind: PotentialAnalysisGivenAnswerKind!
}

enum PotentialAnalysisGivenAnswerKind {
  selected
  SelectedWithFreetext
  Text
}

type PotentialAnalysisMultipleChoiceFreetextQuestion implements PotentialAnalysisQuestion {
  questionText: String!
  answerOptions: [PotentialAnalysisFreetextAnswerOption!]!
  givenAnswers: [PotentialAnalysisSelectedWithFreetextGivenAnswer!]!
  id: ID!
  kind: PotentialAnalysisQuestionDataKind!
}

type PotentialAnalysisMultipleChoiceQuestion implements PotentialAnalysisQuestion {
  questionText: String!
  answerOptions: [PotentialAnalysisSelectAnswerOption!]!
  givenAnswers: [PotentialAnalysisSelectedGivenAnswer!]!
  id: ID!
  kind: PotentialAnalysisQuestionDataKind!
}

type PotentialAnalysisMutations {
  createPotentialAnalysisClickout(input: CreatePotentialAnalysisClickoutInput!): CreatePotentialAnalysisClickoutPayload
  acknowledgePotentialAnalysisMaxReward(input: AcknowledgePotentialAnalysisMaxRewardInput!): AcknowledgePotentialAnalysisMaxRewardPayload
}

interface PotentialAnalysisQuestion {
  id: ID!
  kind: PotentialAnalysisQuestionDataKind!
}

enum PotentialAnalysisQuestionDataKind {
  SINGLE_CHOICE
  SINGLE_CHOICE_FREETEXT
  MULTIPLE_CHOICE
  MULTIPLE_CHOICE_FREETEXT
  TEXT
  SCALE
}

input PotentialAnalysisRegistrationDataInput {
  language: String!
  rvw: Int!
  rvwchk: String!
  ptt: Int!
  pttchk: String!
}

type PotentialAnalysisResult {
  name: String!
  isLongAnalysis: Boolean!
  pdf: File
  categoryResults: [CategoryResult!]!
}

type PotentialAnalysisScaleQuestion implements PotentialAnalysisQuestion {
  questionText: String!
  answerOptions: [PotentialAnalysisSelectAnswerOption!]!
  givenAnswer: PotentialAnalysisSelectedGivenAnswer
  id: ID!
  kind: PotentialAnalysisQuestionDataKind!
}

type PotentialAnalysisSelectAnswerOption implements PotentialAnalysisAnswerOption {
  text: String!
  answerOptionId: Int!
}

input PotentialAnalysisSelectAnswerOptionInput {
  answerOptionId: Int!
  text: String!
}

type PotentialAnalysisSelectedGivenAnswer implements PotentialAnalysisGivenAnswer {
  answerOptionId: Int!
  kind: PotentialAnalysisGivenAnswerKind!
}

input PotentialAnalysisSelectedGivenAnswerInput {
  answerOptionId: Int!
}

type PotentialAnalysisSelectedWithFreetextGivenAnswer implements PotentialAnalysisGivenAnswer {
  answerOptionId: Int!
  freeText: String
  kind: PotentialAnalysisGivenAnswerKind!
}

input PotentialAnalysisSelectedWithFreetextGivenAnswerInput {
  answerOptionId: Int!
  text: String
}

type PotentialAnalysisSingleChoiceFreetextQuestion implements PotentialAnalysisQuestion {
  questionText: String!
  answerOptions: [PotentialAnalysisFreetextAnswerOption!]!
  givenAnswer: PotentialAnalysisSelectedWithFreetextGivenAnswer
  id: ID!
  kind: PotentialAnalysisQuestionDataKind!
}

type PotentialAnalysisSingleChoiceQuestion implements PotentialAnalysisQuestion {
  questionText: String!
  answerOptions: [PotentialAnalysisSelectAnswerOption!]!
  givenAnswer: PotentialAnalysisSelectedGivenAnswer
  id: ID!
  kind: PotentialAnalysisQuestionDataKind!
}

type PotentialAnalysisTextGivenAnswer implements PotentialAnalysisGivenAnswer {
  text: String!
  kind: PotentialAnalysisGivenAnswerKind!
}

input PotentialAnalysisTextGivenAnswerInput {
  text: String!
}

type PotentialAnalysisTextQuestion implements PotentialAnalysisQuestion {
  questionText: String!
  givenAnswer: PotentialAnalysisTextGivenAnswer
  id: ID!
  kind: PotentialAnalysisQuestionDataKind!
}

"""Data partaining to the current user"""
type PotentialAnalysisViewerSchema {
  MyPotentialAnalysisResult: PotentialAnalysisResult
}

type Price {
  netPrice: BigDecimal!
  grossPrice: BigDecimal!
  taxRatePercentage: BigDecimal!
}

input PriceInput {
  netPrice: BigDecimal = 0
  grossPrice: BigDecimal = 0
  taxRatePercentage: BigDecimal = 19
}

type PrivateBaseData implements baseData {
  salutation: SalutationType
  title: String
  firstName: String
  lastName: String
  phoneNumber: String
  city: String
  street: String
  houseNumber: String
  postalCode: String
  countryCode: CountryCode
}

input PrivateBaseDataInput {
  salutation: SalutationType!
  firstName: String!
  lastName: String!
  title: String
  city: String!
  street: String!
  houseNumber: String!
  postalCode: String!
  countryCode: CountryCode!
  phoneNumber: String
}

type PrivateBillingDetails implements BillingDetails {
  invoiceAddress: InvoiceAddress
  dateOfBirth: ZonedDateTIme!
  customerType: CustomerType!
  invoiceEmail: String!
  title: String
  houseNumber: String!
  salutation: SalutationType!
  postalCode: String!
  firstName: String!
  lastName: String!
  country: String!
  street: String!
  city: String!
  phoneNumber: String!
}

interface Product {
  id: ID!
  title: String!
  price: Price!
  isHidden: Boolean!
  productType: String!
}

"""A connection to a list of items."""
type ProductsConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [ProductsEdge]
}

"""An edge in a connection."""
type ProductsEdge {
  """The item at the end of the edge."""
  node: Product!

  """A cursor for use in pagination."""
  cursor: String!
}

type ProductSelectionCondition implements LimitedCartDiscountCondition {
  productId: ID!
  product: Product
  amount: Int!

  """The ID of an object"""
  id: ID!
  kind: LimitedCartDiscountConditionKindEnum!
}

interface ProductSelectionConfig {
  kind: ProductSelectionConfigKindEnum!
}

enum ProductSelectionConfigKindEnum {
  Percentage
}

type ProfileData {
  basicPersonal: ProfileDataBasicPersonal!
  description: String
  jobTitles: [String!]
  quote: String
  socials: ProfileDataSocials
  avatar: File
  languages: [String!]!
  studies: String
  certificateFileIds: [File!]!
  certificateAnswer: Int
  experience: ProfileDataExperience!
  educationFreeText: String
  educationMoreThan150h: Boolean
  coachingStrongPointsTopics: [String!]!
  methods: [String!]!
  digitalAffinity1: Boolean
  digitalAffinity2: Boolean
  personalPhilosophyCoachingStyle: String
  personalPhilosophyVisionMission: String
  referencesCoachingExperienceIds: [File!]!
  referencesPublications: String
}

type ProfileDataBasicPersonal {
  salutation: String
  title: String
  firstName: String
  lastName: String
  email: String
  phoneNumber: String
}

input ProfileDataBasicPersonalInput {
  salutation: String
  title: String
  firstName: String
  lastName: String
  email: String
  phoneNumber: String
}

type ProfileDataExperience {
  coachingHours: Int
  coachingFileIds: [File!]!
  branches: [String!]!
  branchesSteps: [String!]!
}

input ProfileDataExperienceInput {
  coachingHours: Int
  coachingFileIds: [ID!]!
  branches: [String!]!
  branchesSteps: [String!]!
}

input ProfileDataInput {
  basicPersonal: ProfileDataBasicPersonalInput!
  description: String
  avatarId: ID
  quote: String
  jobTitles: [String!]
  socials: ProfileDataSocialsInput
  languages: [String!]!
  studies: String
  certificateFileIds: [ID!]!
  certificateAnswer: Int
  experience: ProfileDataExperienceInput!
  educationFreeText: String
  educationMoreThan150h: Boolean
  coachingStrongPointsTopics: [String!]!
  methods: [String!]!
  digitalAffinity1: Boolean
  digitalAffinity2: Boolean
  personalPhilosophyCoachingStyle: String
  personalPhilosophyVisionMission: String
  referencesCoachingExperienceIds: [ID!]!
  referencesPublications: String
}

type ProfileDataSocials {
  twitter: String
  facebook: String
  linkedIn: String
  website: String
  others: [String!]
}

input ProfileDataSocialsInput {
  twitter: String
  facebook: String
  linkedIn: String
  website: String
  others: [String!]
}

type PublishedConstellationRootExtensionExtension implements PublishedRootExtensionExtension {
  isMicroLearning: Boolean!
  contractPartner: ContractPartner
  licenseAvailability: LicenseAvailability!
  doNotUse: String!
}

type PublishedCourseLearnable implements PublishedLearnable {
  root: LearnOpportunityV2
  id: ID!
  kind: LearnableKind!
}

type PublishedGroupCoachingLearnable implements PublishedLearnable {
  groupCoaching: CoachingOffer
  id: ID!
  kind: LearnableKind!
}

interface PublishedLearnable {
  id: ID!
  kind: LearnableKind!
}

"""A connection to a list of items."""
type PublishedLearnablesConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [PublishedLearnablesEdge]
}

"""An edge in a connection."""
type PublishedLearnablesEdge {
  """The item at the end of the edge."""
  node: PublishedLearnable!

  """A cursor for use in pagination."""
  cursor: String!
}

type PublishedMicroLearningLearnable implements PublishedLearnable {
  root: LearnOpportunityV2
  id: ID!
  kind: LearnableKind!
}

type PublishedOneToOneCoachingLearnable implements PublishedLearnable {
  oneToOneCoaching: CoachingOffer
  id: ID!
  kind: LearnableKind!
}

interface PublishedRootExtensionExtension {
  doNotUse: String!
}

type PublishedRootExtensionImpl implements LearnOpportunityRootExtension {
  reducedData: ReducedData
  learnGoals: String
  trailer: StreamFile
  systemTags: [SystemTag!]!
  tags: [AcademiesTag!]!
  ihkState: IHKCertificateOrderStateKind!
  cartClickout: CartClickout
  licenseProduct: LicenseProduct
  unlockInfo: UnlockInfo!
  receivedGamificationPoints: Int!
  diploma: String
  extension: PublishedRootExtensionExtension!
  doNotUse: String!
}

type PublishingMessageV2 {
  message: String!
  additionalMessage: String
  timestamp: ZonedDateTIme!
}

enum PublishingStatus {
  succeeded
  inprogress
  failed
  acknowledged
}

type PublishingUpdatedEventV2 {
  tree: Tree!
  publishing: PublishingV2!
  name: String!
}

type PublishingV2 implements Node {
  """The ID of an object"""
  id: ID!
  status: PublishingStatus!
  messages: [PublishingMessageV2!]!
  initiatedAt: ZonedDateTIme!
  finishedAt: ZonedDateTIme
  canBeAcknowledged: Boolean!
}

"""Data only accessible by the admin"""
type PublishingV2AdminMutationSchema {
  acknowledgePublishingV2(input: AcknowledgePublishingV2Input!): AcknowledgePublishingV2Payload
  startPublishingV2(input: StartPublishingV2Input!): StartPublishingV2Payload
}

"""Data only accessible by the admin"""
type PublishingV2AdminSchema {
  ActivePublishing(rootId: ID!): PublishingV2
}

type Purchaser {
  userId: ID!
  accountId: ID!
}

type PurchaseUpdate implements HistoryEventInterface {
  kind: HistoryEventType!
}

type Query {
  FeatureToggle: FeatureToggleQueries!
  Learn: LearnQueries!
  Auth: AuthQueries!
  Coaching: CoachingQueries!
  Learnable: LearnableQueries!
  CustomerJourney: CustomerJourneyQueries!
  Ping: PingQueries!
  AvgsPotentialAnalysis: AvgsPotentialAnalysisQueries!
  Management: ManagementQueries!
  AccountMemberManagement: AccountMemberManagementQueries!
  LicenseGrouping: LicenseGroupingQueries!
  AcademiesTag: AcademiesTagQueries!
  AccountBaseData: AccountBaseDataQueries!
  Vocab: VocabQueries!
  Placement: PlacementQueries!

  """Data partaining to the current user"""
  Viewer: ViewerQueryType!

  """Data only accessible by the admin"""
  Admin: AdminQueryType!

  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Fetches objects given their IDs"""
  nodes(
    """The IDs of objects"""
    ids: [ID!]!
  ): [Node]!
}

input RearrangeElementsV2Input {
  eLearningContentNodeId: ID!
  newElementIds: [ID!]!
  clientMutationId: String
}

type RearrangeElementsV2Payload {
  eLearningContentNode: TreeNode!
  clientMutationId: String
}

type ReducedData {
  containsVideo: Boolean!
  numAttachments: Int!
  numBranches: Int!
  numContents: Int!
  videoDurationInSec: Long!
  isIHK: Boolean!
  receivableGamificationPoints: Int!
}

type Refusal {
  refusalReason: RefusalReason!
  code: String!
  title: String!
  discountCodeId: ID!
}

enum RefusalReason {
  OverUserLimit
  OverLimit
  WrongAccount
  WrongProducts
  DuplicatedUserCode
  DuplicatedSystemCode
  Expired
}

input RegisterForNotificationInput {
  service: NotificationServiceType!
  token: String!
  clientMutationId: String
}

type RegisterForNotificationPayload {
  clientMutationId: String
}

input RegisterParticipationAdminInput {
  availabilityId: ID!
  participantId: ID!
  participationStatus: ParticipationStatus!
  clientMutationId: String
}

type RegisterParticipationAdminPayload {
  availability: Availability!
  clientMutationId: String
}

input RegisterParticipationInput {
  availabilityId: ID!
  participantId: ID!
  participationStatus: ParticipationStatus!
  clientMutationId: String
}

type RegisterParticipationPayload {
  availability: Availability!
  clientMutationId: String
}

input RegisterUserInput {
  email: String!
  rawPassword: String!
  firstName: String!
  lastName: String!
  position: String
  adsOptIn: Boolean!
  potentialAnalysisRegistrationData: PotentialAnalysisRegistrationDataInput
  branch: Branch
  teamSize: TeamSize
  clientMutationId: String
}

type RegisterUserPayload {
  firstLogin: Boolean!
  accountId: ID!
  userId: ID!
  clientMutationId: String
}

type ReleasedFileV2 {
  file: File
}

type ReleasedSubtitlesV2 {
  vimeoId: String!
  subtitles: SubtitlesV2
}

input RemoveAttachmentInput {
  nodeId: ID!
  attachmentId: ID!
  clientMutationId: String
}

type RemoveAttachmentPayload {
  node: TreeNode!
  clientMutationId: String
}

input RemoveColumnFromMatrixElementInput {
  idx: Int!
  matrixElementId: ID!
  clientMutationId: String
}

type RemoveColumnFromMatrixElementPayload {
  eLearningContent: TreeNode!
  matrixElement: MatrixElement!
  clientMutationId: String
}

input RemoveNodeFromTreeInput {
  nodeId: ID!
  clientMutationId: String
}

type RemoveNodeFromTreePayload {
  tree: Tree!
  clientMutationId: String
}

input RemoveOrderItemInput {
  orderElementId: ID!
  orderItemId: ID!
  clientMutationId: String
}

type RemoveOrderItemPayload {
  orderElement: OrderElement!
  clientMutationId: String
}

input RemoveParticipantAdminInput {
  availabilityId: ID!
  participantId: ID!
  clientMutationId: String
}

type RemoveParticipantAdminPayload {
  availability: Availability!
  clientMutationId: String
}

input RemoveParticipantFromBookingAsCoachInput {
  availabilityId: ID!
  participantId: ID!
  clientMutationId: String
}

type RemoveParticipantFromBookingAsCoachPayload {
  availability: Availability!
  clientMutationId: String
}

input RemoveParticipantFromMyBookingInput {
  availabilityId: ID!
  participantId: ID!
  clientMutationId: String
}

type RemoveParticipantFromMyBookingPayload {
  availability: Availability!
  clientMutationId: String
}

input RemoveRestartIfFailedContentConfigInput {
  contentNodeId: ID!
  configId: ID!
  clientMutationId: String
}

type RemoveRestartIfFailedContentConfigPayload {
  contentNode: TreeNode!
  clientMutationId: String
}

input RemoveRewardTreeConfigInput {
  rootNodeId: ID!
  configId: ID!
  clientMutationId: String
}

type RemoveRewardTreeConfigPayload {
  rootNode: TreeNode!
  clientMutationId: String
}

input RemoveRowFromMatrixElementInput {
  idx: Int!
  matrixElementId: ID!
  clientMutationId: String
}

type RemoveRowFromMatrixElementPayload {
  eLearningContent: TreeNode!
  matrixElement: MatrixElement!
  clientMutationId: String
}

input RemoveStartContentConfigInput {
  contentNodeId: ID!
  configId: ID!
  clientMutationId: String
}

type RemoveStartContentConfigPayload {
  contentNode: TreeNode!
  clientMutationId: String
}

input RemoveStartTreeConfigInput {
  rootNodeId: ID!
  configId: ID!
  clientMutationId: String
}

type RemoveStartTreeConfigPayload {
  rootNode: TreeNode!
  clientMutationId: String
}

input RemoveUserFromAccountInput {
  userId: ID!
  accountId: ID!
  clientMutationId: String
}

type RemoveUserFromAccountPayload {
  removedUserId: ID!
  clientMutationId: String
}

input RemoveUsersFromAccountInput {
  userIds: [ID!]!
  clientMutationId: String
}

type RemoveUsersFromAccountPayload {
  removedIds: [ID!]!
  clientMutationId: String
}

input RemoveUsersFromUserInAccountGroupInput {
  groupId: ID!
  userIds: [ID!]!
  clientMutationId: String
}

type RemoveUsersFromUserInAccountGroupPayload {
  removedIds: [ID!]!
  clientMutationId: String
}

input RemoveVisibilityCoachingConfigInput {
  coachingOfferId: ID!
  configId: ID!
  clientMutationId: String
}

type RemoveVisibilityCoachingConfigPayload {
  coachingOffer: CoachingOffer!
  clientMutationId: String
}

input RemoveVisibilityTreeConfigInput {
  rootNodeId: ID!
  configId: ID!
  clientMutationId: String
}

type RemoveVisibilityTreeConfigPayload {
  rootNode: TreeNode!
  clientMutationId: String
}

input RemoveWrongAnswerFromMatrixElementCellInput {
  matrixElementId: ID!
  matrixCellId: ID!
  wrongAnswerId: ID!
  clientMutationId: String
}

type RemoveWrongAnswerFromMatrixElementCellPayload {
  eLearningContent: TreeNode!
  matrixElement: MatrixElement!
  clientMutationId: String
}

"""Data only accessible by the admin"""
type ReportsAdminSchema {
  Reports(before: String, after: String, first: Int, last: Int, referenceNumber: String): DSAReportConnection!
}

type ReportsMutations {
  createReport(input: CreateReportInput!): CreateReportPayload
}

"""Data partaining to the current user"""
type ReportsViewerSchema {
  SystemEmail: String!
}

input ResendActivationInput {
  email: String!
  clientMutationId: String
}

type ResendActivationPayload {
  clientMutationId: String
}

input ResetAllStagingDataInput {
  clientMutationId: String
}

type ResetAllStagingDataPayload {
  clientMutationId: String
}

input ResetPasswordAndActivateInput {
  token: String!
  newPassword: String!
  clientMutationId: String
}

type ResetPasswordAndActivatePayload {
  clientMutationId: String
}

input ResetStagingBillingInput {
  clientMutationId: String
}

type ResetStagingBillingPayload {
  clientMutationId: String
}

input ResetStagingUsersInput {
  clientMutationId: String
}

type ResetStagingUsersPayload {
  clientMutationId: String
}

input RestartContentNodeAfterFailedInput {
  contentNodeId: ID!
  clientMutationId: String
}

type RestartContentNodeAfterFailedPayload {
  contentSubmission: ContentSubmission!
  clientMutationId: String
}

input RestartContentNodeAfterPassedInput {
  contentNodeId: ID!
  clientMutationId: String
}

type RestartContentNodeAfterPassedPayload {
  contentSubmission: ContentSubmission!
  clientMutationId: String
}

interface RestartIfFailedContentConfig {
  """The ID of an object"""
  id: ID!
  configType: RestartIfFailedContentConfigType!
}

interface RestartIfFailedContentConfigResult {
  canBeRestarted: Boolean!
  configType: RestartIfFailedContentConfigType!
}

enum RestartIfFailedContentConfigType {
  RestartIfFailedContent_CanNot
  RestartIfFailedContent_BlockTemporarily
  RestartIfFailedContent_BlockPermanently
}

interface RestartIfPassedContentConfig {
  """The ID of an object"""
  id: ID!
  configType: RestartIfPassedContentConfigType!
}

enum RestartIfPassedContentConfigType {
  RestartIfPassedContent_Can
  RestartIfPassedContent_CanNot
}

interface Reward {
  """The ID of an object"""
  id: ID!
  superId: ID!
  kind: RewardKind!
}

interface RewardContentConfig {
  """The ID of an object"""
  id: ID!
  configType: RewardContentConfigType!
}

enum RewardContentConfigType {
  RewardContent_Do
}

enum RewardKind {
  ExternalLicense
  CrmTreeHeadUpdater
  WordPackage
  ParticipationCertificate
  WordProficiencies
  GamificationPoints
  IHKCertificate
}

interface RewardResult {
  rewardId: ID!
  rewardKind: RewardKind!
  kind: RewardResultKind!
}

enum RewardResultKind {
  ExternalLicense_IssuedToUser
  ExternalLicense_NotPassed
  ExternalLicense_ErrorOccurred
  CrmTreeHeadUpdater_ErrorOccurred
  CrmTreeHeadUpdater_NotPassed
  CrmTreeHeadUpdater_HeadUpdated
  WordPackage_ErrorOccurred
  WordPackage_NothingNewToUnlock
  WordPackage_PackageUnlocked
  ParticipationCertificate_ParticipationCertificate
  WordProficiencies_ErrorOccurred
  WordProficiencies_ProficienciesChanged
  GamificationPoints_AlreadyReceivedPoints
  GamificationPoints_ErrorOccurred
  GamificationPoints_NoPointsReceived
  GamificationPoints_NotPassedIHKTestFlow
  GamificationPoints_PointsReceived
  IHKCertificate_ErrorOccurred
  IHKCertificate_ReadyToOrder
}

interface RewardTreeConfig {
  """The ID of an object"""
  id: ID!
  configType: RewardTreeConfigType!
}

enum RewardTreeConfigType {
  RewardTree_DoNot
}

type RootCost {
  supplier: String!
  price: BigDecimal!
  percentageShare: Int!
}

input RootCostInput {
  supplier: String!
  price: BigDecimal!
  percentageShare: Int!
}

interface RootExtension {
  doNotUse: String!
}

interface RootExtensionExtension {
  doNotUse: String!
}

type RootExtensionImpl implements RootExtension {
  learnGoalsOpt: String
  trailerOpt: String
  cost: RootCost
  tags: [AcademiesTag!]!
  licenseProduct: LicenseProduct
  diploma: String
  extension: RootExtensionExtension!
  doNotUse: String!
}

type RootStructureDefinition implements StructureDefinition {
  extension: RootExtension!
  firstReleasedAt: ZonedDateTIme
  icon: File
  searchWords: String
  tags: [Tag!]!
  visibilityConfigs: [VisibilityTreeConfig!]!
  startConfigs: [StartTreeConfig!]!
  startAtConfig: StartAtTreeConfig!
  rewardConfigs: [RewardTreeConfig!]!
  showAnswerConfig: ShowAnswerTreeConfig!
  title: String!
  coordinates: CoordinatesV2!
  definitionType: StructureType!
}

enum SalutationType {
  Mr
  Mrs
  Divers
  Unknown
}

type ScheduleData {
  daysAndTimes: [AvailabilityScheduleDayAndTimes!]!
  overrideDaysAndTimesForCalendarWeek: [DayAndTimesForCalendarWeek!]!
  blockoutDates: [BlockoutDate!]!
}

input ScheduleDataInput {
  daysAndTimes: [DayAndTimesInput!]!
  blockoutDates: [BlockoutDateInput!]!
  overrideDaysAndTimesForCalendarWeek: [DayAndTimesForCalendarWeekInput!]!
}

"""result of searching discount code usages."""
type SearchDiscountCodeUsagesResult {
  usages(before: String, after: String, first: Int, last: Int): DiscountCodeUsagesConnection!
  sumGrossPriceWithoutDiscounts: BigDecimal!
  sumGrossPriceWithDiscounts: BigDecimal!
  csv: String!
}

interface SelectedPaymentMethod {
  paymentMethodId: PaymentMethodType!
  selectedPaymentMethodType: SelectedPaymentMethodType!
}

enum SelectedPaymentMethodType {
  OneTimePayment
  MonthlyPayment
  EmployerInvoice
}

type SelectedProduct {
  amount: Int!
  product: Product
}

input SelectedProductInput {
  amount: Int!
  additionalInformation: String
  productId: ID!
}

type Selection {
  createdByUser: User
  selectedProducts: [SelectedProduct!]!
  selectedDiscountCodes: [String!]!
}

input SendAskCompanyIfContractWasConcludedInput {
  jobListingTitle: String!
  linkId: String!
  contactPersonUserId: ID!
  contactPersonAccountId: ID!
  clientMutationId: String
}

type SendAskCompanyIfContractWasConcludedPayload {
  clientMutationId: String
}

input SendCompanyIsInterestedInUserProfileInput {
  jobListingInterestedYes: Boolean!
  linkId: String!
  jobListingTitle: String!
  userId: ID!
  deadlineMatching: ZonedDateTIme!
  clientMutationId: String
}

type SendCompanyIsInterestedInUserProfilePayload {
  clientMutationId: String
}

input SendEmailInput {
  email: String!
  personalizedEmailTemplateId: ID!
  clientMutationId: String
}

type SendEmailPayload {
  clientMutationId: String
}

input SendInformAboutAcceptedMatchingInput {
  jobListingTitle: String!
  userId: ID!
  businessAccountId: ID!
  clientMutationId: String
}

type SendInformAboutAcceptedMatchingPayload {
  clientMutationId: String
}

input SendInformAboutAvailableDossierInput {
  jobListingTitle: String!
  jobListingId: String!
  businessUserId: ID!
  businessAccountId: ID!
  clientMutationId: String
}

type SendInformAboutAvailableDossierPayload {
  clientMutationId: String
}

input SendMatchingResultsAvailableToBusinessInput {
  linkId: String!
  businessUserId: ID!
  businessAccountId: ID!
  deadlineMatching: ZonedDateTIme!
  clientMutationId: String
}

type SendMatchingResultsAvailableToBusinessPayload {
  clientMutationId: String
}

input SendMatchingResultsAvailableToUserInput {
  linkId: String!
  userId: ID!
  deadlineMatching: ZonedDateTIme!
  clientMutationId: String
}

type SendMatchingResultsAvailableToUserPayload {
  clientMutationId: String
}

input SendRemindCompanyToPayFeeInput {
  jobListingTitle: String!
  managerUserId: ID!
  managerAccountId: ID!
  clientMutationId: String
}

type SendRemindCompanyToPayFeePayload {
  clientMutationId: String
}

input SendReminderForInviteToSecondInterviewInput {
  linkId: String!
  jobListingTitle: String!
  contactPersonUserId: ID!
  contactPersonAccountId: ID!
  deadlineMatching: ZonedDateTIme!
  clientMutationId: String
}

type SendReminderForInviteToSecondInterviewPayload {
  clientMutationId: String
}

input SendReminderForSecondInterviewToUserInput {
  linkId: String!
  userId: ID!
  deadlineMatching: ZonedDateTIme!
  clientMutationId: String
}

type SendReminderForSecondInterviewToUserPayload {
  clientMutationId: String
}

input SendSummaryForFirstInterviewToContactPersonInput {
  jobListingTitle: String!
  linkId: String!
  userId: ID!
  accountId: ID!
  interviewDate: ZonedDateTIme!
  clientMutationId: String
}

type SendSummaryForFirstInterviewToContactPersonPayload {
  clientMutationId: String
}

input SendSummaryForFirstInterviewToUserInput {
  linkId: String!
  userId: ID!
  interviewDate: ZonedDateTIme!
  clientMutationId: String
}

type SendSummaryForFirstInterviewToUserPayload {
  clientMutationId: String
}

input SendSummaryForSecondInterviewToContactPersonInput {
  jobListingTitle: String!
  linkId: String!
  contactPersonUserId: ID!
  contactPersonAccountId: ID!
  interviewDate: ZonedDateTIme!
  clientMutationId: String
}

type SendSummaryForSecondInterviewToContactPersonPayload {
  clientMutationId: String
}

input SendSummaryForSecondInterviewToUserInput {
  linkId: String!
  userId: ID!
  businessAccountId: ID!
  interviewDate: ZonedDateTIme!
  clientMutationId: String
}

type SendSummaryForSecondInterviewToUserPayload {
  clientMutationId: String
}

input SendUserIsInterestedForJobListingInput {
  jobListingTitle: String!
  linkId: String!
  userId: ID!
  contactPersonUserId: ID!
  contactPersonAccountId: ID!
  deadlineMatching: ZonedDateTIme!
  clientMutationId: String
}

type SendUserIsInterestedForJobListingPayload {
  clientMutationId: String
}

type SepaData implements PaymentProviderData {
  paymentMethod: PaymentMethodType!
  dataType: PaymentProviderDataType!
  mandateInformation: MandateInformation!
  iban: String!
}

type SessionLineItem {
  coach: User
  coachingOffer: CoachingOffer
  sessionFrom: ZonedDateTIme!
  sessionTo: ZonedDateTIme!
  remuneration: Price!
}

input SetAccountBaseDataCountryInput {
  countryCode: CountryCode!
  clientMutationId: String
}

type SetAccountBaseDataCountryPayload {
  baseData: baseData!
  clientMutationId: String
}

input SetAccountGroupsInput {
  id: ID!
  groupIds: [ID!]!
  clientMutationId: String
}

type SetAccountGroupsPayload {
  account: Account!
  clientMutationId: String
}

input SetAccountNameInput {
  name: String!
  id: ID!
  clientMutationId: String
}

type SetAccountNamePayload {
  account: Account!
  clientMutationId: String
}

input SetAccountNameUserInput {
  name: String!
  id: ID!
  clientMutationId: String
}

type SetAccountNameUserPayload {
  account: Account!
  clientMutationId: String
}

input SetAlwaysPassContentConfigInput {
  contentNodeId: ID!
  clientMutationId: String
}

type SetAlwaysPassContentConfigPayload {
  contentNode: TreeNode!
  clientMutationId: String
}

input SetAlwaysRestartContinueContentConfigInput {
  contentNodeId: ID!
  clientMutationId: String
}

type SetAlwaysRestartContinueContentConfigPayload {
  contentNode: TreeNode!
  clientMutationId: String
}

input SetAnswerInMultipleChoiceFreeTextQuestionInput {
  questionText: String!
  learnPotentialAnalysisId: ID!
  questionId: ID!
  answerOptions: [PotentialAnalysisFreeTextAnswerOptionInput!]!
  givenAnswer: [PotentialAnalysisSelectedWithFreetextGivenAnswerInput!]!
  clientMutationId: String
}

type SetAnswerInMultipleChoiceFreeTextQuestionPayload {
  isFinished: Boolean!
  question: PotentialAnalysisMultipleChoiceFreetextQuestion
  clientMutationId: String
}

input SetAnswerInMultipleChoiceQuestionInput {
  questionText: String!
  learnPotentialAnalysisId: ID!
  questionId: ID!
  answerOptions: [PotentialAnalysisSelectAnswerOptionInput!]!
  givenAnswer: [PotentialAnalysisSelectedGivenAnswerInput!]!
  clientMutationId: String
}

type SetAnswerInMultipleChoiceQuestionPayload {
  isFinished: Boolean!
  question: PotentialAnalysisMultipleChoiceQuestion!
  clientMutationId: String
}

input SetAnswerInScaleQuestionInput {
  questionText: String!
  learnPotentialAnalysisId: ID!
  questionId: ID!
  answerOptions: [PotentialAnalysisSelectAnswerOptionInput!]!
  givenAnswer: PotentialAnalysisSelectedGivenAnswerInput!
  clientMutationId: String
}

type SetAnswerInScaleQuestionPayload {
  isFinished: Boolean!
  question: PotentialAnalysisScaleQuestion!
  clientMutationId: String
}

input SetAnswerInSingleChoiceFreeTextQuestionInput {
  questionText: String!
  learnPotentialAnalysisId: ID!
  questionId: ID!
  answerOptions: [PotentialAnalysisFreeTextAnswerOptionInput!]!
  givenAnswer: PotentialAnalysisSelectedWithFreetextGivenAnswerInput!
  clientMutationId: String
}

type SetAnswerInSingleChoiceFreeTextQuestionPayload {
  isFinished: Boolean!
  question: PotentialAnalysisSingleChoiceFreetextQuestion
  clientMutationId: String
}

input SetAnswerInSingleChoiceQuestionInput {
  questionText: String!
  learnPotentialAnalysisId: ID!
  questionId: ID!
  answerOptions: [PotentialAnalysisSelectAnswerOptionInput!]!
  givenAnswer: PotentialAnalysisSelectedGivenAnswerInput!
  clientMutationId: String
}

type SetAnswerInSingleChoiceQuestionPayload {
  isFinished: Boolean!
  question: PotentialAnalysisSingleChoiceQuestion!
  clientMutationId: String
}

input SetAnswerInTextQuestionInput {
  questionText: String!
  learnPotentialAnalysisId: ID!
  questionId: ID!
  givenAnswer: PotentialAnalysisTextGivenAnswerInput!
  clientMutationId: String
}

type SetAnswerInTextQuestionPayload {
  isFinished: Boolean!
  question: PotentialAnalysisTextQuestion
  clientMutationId: String
}

input SetCanNotRestartIfPassedContentConfigInput {
  contentNodeId: ID!
  clientMutationId: String
}

type SetCanNotRestartIfPassedContentConfigPayload {
  contentNode: TreeNode!
  clientMutationId: String
}

input SetCanRestartIfPassedContentConfigInput {
  contentNodeId: ID!
  clientMutationId: String
}

type SetCanRestartIfPassedContentConfigPayload {
  contentNode: TreeNode!
  clientMutationId: String
}

input SetConstellationRootExtensionExtensionInput {
  isMicroLearning: Boolean!
  rootId: ID!
  clientMutationId: String
}

type SetConstellationRootExtensionExtensionPayload {
  root: TreeNode!
  clientMutationId: String
}

input SetContractPartnerInConstellationRootExtensionExtensionInput {
  rootId: ID!
  contractPartner: ID
  clientMutationId: String
}

type SetContractPartnerInConstellationRootExtensionExtensionPayload {
  root: TreeNode!
  clientMutationId: String
}

input SetCorrectAnswerInMatrixElementCellInput {
  newCorrectAnswerContent: String!
  matrixElementId: ID!
  matrixCellId: ID!
  clientMutationId: String
}

type SetCorrectAnswerInMatrixElementCellPayload {
  eLearningContent: TreeNode!
  matrixElement: MatrixElement!
  clientMutationId: String
}

input SetDirectFeedbackFlowELearningContentConfigInput {
  minNumTriesTillShowAnswer: Int!
  contentId: ID!
  clientMutationId: String
}

type SetDirectFeedbackFlowELearningContentConfigPayload {
  content: TreeNode!
  clientMutationId: String
}

input SetDoNotShowAnswerTreeConfigInput {
  rootNodeId: ID!
  clientMutationId: String
}

type SetDoNotShowAnswerTreeConfigPayload {
  rootNode: TreeNode!
  clientMutationId: String
}

input SetDoRewardContentConfigInput {
  contentNodeId: ID!
  clientMutationId: String
}

type SetDoRewardContentConfigPayload {
  contentNode: TreeNode!
  clientMutationId: String
}

input SetGlobalDiscountCodeIdInput {
  discountCodeId: ID
  clientMutationId: String
}

type SetGlobalDiscountCodeIdPayload {
  settings: Settings!
  clientMutationId: String
}

input SetIHKFlowPassContentConfigInput {
  contentNodeId: ID!
  clientMutationId: String
}

type SetIHKFlowPassContentConfigPayload {
  content: TreeNode!
  clientMutationId: String
}

input SetMatrixElementColumnTitleInput {
  idx: Int!
  newTitle: String!
  matrixElementId: ID!
  clientMutationId: String
}

type SetMatrixElementColumnTitlePayload {
  eLearningContent: TreeNode!
  matrixElement: MatrixElement!
  clientMutationId: String
}

input SetMatrixElementRowTitleInput {
  idx: Int!
  newTitle: String!
  matrixElementId: ID!
  clientMutationId: String
}

type SetMatrixElementRowTitlePayload {
  eLearningContent: TreeNode!
  matrixElement: MatrixElement!
  clientMutationId: String
}

input SetRootExtensionImplInput {
  learnGoals: String
  trailerVimeoId: String
  cost: RootCostInput
  diploma: String
  rootId: ID!
  tagIds: [ID!]!
  licenseProductId: ID
  clientMutationId: String
}

type SetRootExtensionImplPayload {
  root: TreeNode!
  clientMutationId: String
}

input SetSimplyContinueFlowELearningContentConfigInput {
  contentId: ID!
  clientMutationId: String
}

type SetSimplyContinueFlowELearningContentConfigPayload {
  content: TreeNode!
  clientMutationId: String
}

type Settings {
  """The ID of an object"""
  id: ID!
  globalDiscountCode: DiscountCode
}

"""Data only accessible by the admin"""
type SettingsAdminMutationSchema {
  setGlobalDiscountCodeId(input: SetGlobalDiscountCodeIdInput!): SetGlobalDiscountCodeIdPayload
}

"""Data only accessible by the admin"""
type SettingsAdminSchema {
  Settings(before: String, after: String, first: Int, last: Int): Settings!
}

input SetTrendOrderInput {
  trendIdsWithPositions: [TrendIdWithPosition!]!
  clientMutationId: String
}

type SetTrendOrderPayload {
  clientMutationId: String
}

input SetUserInAccountGroupsInput {
  accountId: ID!
  userId: ID!
  groupIds: [ID!]!
  clientMutationId: String
}

type SetUserInAccountGroupsPayload {
  userInAccount: UserInAccountEdge!
  clientMutationId: String
}

interface ShowAnswerElementState {
  element: LearnElement!
  kind: ElementStateKind!
}

interface ShowAnswerTreeConfig {
  """The ID of an object"""
  id: ID!
  configType: ShowAnswerTreeConfigType!
}

enum ShowAnswerTreeConfigType {
  ShowAnswerTree_DoNot
}

input ShowElementAnswerElementInput {
  contentSubmissionId: ID!
  inputElementId: ID!
  clientMutationId: String
}

type ShowElementAnswerElementPayload {
  contentSubmission: ContentSubmission!
  clientMutationId: String
}

type SimplyContinueFlowELearningContentConfig implements FlowELearningContentConfig {
  """The ID of an object"""
  id: ID!
  configType: FlowELearningContentConfigType!
}

type SingleUserAssignmentRule implements AssignmentRule & Node {
  userId: ID!
  maxLicenseAmount: Int!
  licensesUsedByUser: Int!

  """The ID of an object"""
  id: ID!
  licenseGroupingId: ID!
  accountRef: ID!
}

"""A connection to a list of items."""
type SortedLearnablesConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [SortedLearnablesEdge]
}

"""An edge in a connection."""
type SortedLearnablesEdge {
  """The item at the end of the edge."""
  node: LearnableWithLastUpdated!

  """A cursor for use in pagination."""
  cursor: String!
}

"""Data only accessible by the admin"""
type StagingAdminMutationSchema {
  createCoachStatementsFromUnbilled(input: CreateCoachStatementsFromUnbilledInput!): CreateCoachStatementsFromUnbilledPayload
  resetAllStagingData(input: ResetAllStagingDataInput!): ResetAllStagingDataPayload
  cleanUpUserInputRelatedToStaging(input: CleanUpUserInputRelatedToStagingInput!): CleanUpUserInputRelatedToStagingPayload
  resetStagingUsers(input: ResetStagingUsersInput!): ResetStagingUsersPayload
  resetStagingBilling(input: ResetStagingBillingInput!): ResetStagingBillingPayload
}

interface StartAtTreeConfig {
  """The ID of an object"""
  id: ID!
  configType: StartAtTreeConfigType!
}

enum StartAtTreeConfigType {
  StartAtTree_FirstContentNode
}

interface StartContentConfig {
  """The ID of an object"""
  id: ID!
  configType: StartContentConfigType!
}

enum StartContentConfigType {
  StartContent_CanNot
  StartContent_CanIfInTreeFlow
  StartContent_CanIfUnlocked
  StartContent_CanAfterStartingTree
}

input StartContentNodeInput {
  contentNodeId: ID!
  clientMutationId: String
}

type StartContentNodePayload {
  contentSubmission: ContentSubmission!
  clientMutationId: String
}

input StartPublishingV2Input {
  rootNodeId: ID!
  clientMutationId: String
}

type StartPublishingV2Payload {
  tree: Tree!
  clientMutationId: String
}

input StartStandaloneVocabTrainingInput {
  numWords: Int!
  words: [WordInPackageInput!]!
  clientMutationId: String
}

type StartStandaloneVocabTrainingPayload {
  contentSubmission: ContentSubmission!
  clientMutationId: String
}

interface StartTreeConfig {
  """The ID of an object"""
  id: ID!
  configType: StartTreeConfigType!
}

enum StartTreeConfigType {
  StartTree_CanNot
}

input StartTreeInput {
  nodeId: ID!
  startAtContentNodeId: ID
  clientMutationId: String
}

type StartTreePayload {
  learnOpportunity: LearnOpportunityV2!
  clientMutationId: String
}

type StreamFile {
  """The ID of an object"""
  id: ID!
  thumbnail: String
  url: String
}

type StripeData implements PaymentProviderData {
  paymentMethod: PaymentMethodType!
  dataType: PaymentProviderDataType!
  paymentIntentId: String!
  paymentIntentSecret: String!
}

type StripeSepaData implements PaymentProviderData {
  paymentMethod: PaymentMethodType!
  dataType: PaymentProviderDataType!
  mandateInformation: MandateInformation!
  paymentIntentId: String!
  paymentIntentSecret: String!
}

interface StructureDefinition {
  title: String!
  coordinates: CoordinatesV2!
  definitionType: StructureType!
}

enum StructureType {
  root
  child
}

input SubmitClozeTextElementV2Input {
  contentSubmissionId: ID!
  clozeTextElementId: ID!
  checkedAnswers: [ID!]!
  clientMutationId: String
}

type SubmitClozeTextElementV2Payload {
  contentSubmission: ContentSubmission!
  clientMutationId: String
}

input SubmitDisplayElementInput {
  contentSubmissionId: ID!
  displayElementId: ID!
  clientMutationId: String
}

type SubmitDisplayElementPayload {
  contentSubmission: ContentSubmission!
  clientMutationId: String
}

input SubmitMarkMistakesElementV2Input {
  checkedMistakeIndices: [Int!]!
  contentSubmissionId: ID!
  markMistakesElementId: ID!
  clientMutationId: String
}

type SubmitMarkMistakesElementV2Payload {
  contentSubmission: ContentSubmission!
  clientMutationId: String
}

input SubmitMatrixElementV2Input {
  checkedIndices: [SubmitMatrixIndexCellInput!]!
  contentSubmissionId: ID!
  matrixElementId: ID!
  clientMutationId: String
}

type SubmitMatrixElementV2Payload {
  contentSubmission: ContentSubmission!
  clientMutationId: String
}

input SubmitMatrixIndexCellInput {
  xIdx: Int!
  yIdx: Int!
  index: Int!
}

input SubmitMultipleChoiceElementV2Input {
  checkedAnswerIndices: [Int!]!
  contentSubmissionId: ID!
  multipleChoiceElementId: ID!
  clientMutationId: String
}

type SubmitMultipleChoiceElementV2Payload {
  contentSubmission: ContentSubmission!
  clientMutationId: String
}

input SubmitOrderElementInput {
  contentSubmissionId: ID!
  orderElementId: ID!
  order: [ID!]!
  clientMutationId: String
}

type SubmitOrderElementPayload {
  contentSubmission: ContentSubmission!
  clientMutationId: String
}

input SubmitUploadAsyncElementInput {
  contentSubmissionId: ID!
  uploadAsyncElementId: ID!
  fileId: ID!
  clientMutationId: String
}

type SubmitUploadAsyncElementPayload {
  contentSubmission: ContentSubmission!
  clientMutationId: String
}

type Subscription {
  subscribeToPublishingUpdatesV2: PublishingUpdatedEventV2!
}

enum SubtitleLanguage {
  en
  de
}

type SubtitlesForLanguage {
  language: SubtitleLanguage!
  subtitles: [VideoSubtitle!]!
  transcriptFileId: File
}

type SubtitlesV2 {
  subtitles: [SubtitleV2!]!
}

type SubtitleV2 {
  startTime: Long!
  endTime: Long!
  text: String!
}

input SwitchAccountInput {
  refreshToken: String!
  targetAccount: ID!
  clientMutationId: String
}

type SwitchAccountPayload {
  jwtTokens: JwtLoginInformation!
  clientMutationId: String
}

input SyncHubspotContactsWithUsersInput {
  clientMutationId: String
}

type SyncHubspotContactsWithUsersPayload {
  clientMutationId: String
}

type SystemDiscountType implements DiscountType {
  kind: DiscountTypeKind!
}

enum SystemTag {
  finished
  fullAccess
  new
  testAccess
}

type Tag implements Node {
  name: String!
  colorHex: String!

  """The ID of an object"""
  id: ID!
}

"""Data only accessible by the admin"""
type TagAdminMutationSchema {
  createTag(input: CreateTagInput!): CreateTagPayload
  updateTag(input: UpdateTagInput!): UpdateTagPayload
  deleteTag(input: DeleteTagInput!): DeleteTagPayload
}

"""Data only accessible by the admin"""
type TagAdminSchema {
  Tags(before: String, after: String, first: Int, last: Int, filterByName: String): TagsConnection!
}

input TagDataInput {
  name: String!
  isTopic: Boolean!
  isClickable: Boolean!
}

input TagInput {
  name: String!
  colorHex: String!
  clientMutationId: String
}

"""A connection to a list of items."""
type TagsConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [TagsEdge]
}

"""An edge in a connection."""
type TagsEdge {
  """The item at the end of the edge."""
  node: Tag!

  """A cursor for use in pagination."""
  cursor: String!
}

enum TargetSystem {
  ios
  android
}

type TaxData {
  taxNumber: String!
  taxIdentificationNumber: String!
}

input TaxDataInput {
  taxNumber: String!
  taxIdentificationNumber: String!
}

type TaxTotals {
  taxTotal: BigDecimal!
  discountTotal: BigDecimal!
  netPrice: BigDecimal!
  grossPrice: BigDecimal!
  hasTaxFreeProducts: Boolean!
}

enum TeamSize {
  oneToTen
  tenToTwentyFive
  twentyFiveToFifty
  fiftyToHundred
  overHundred
}

type TextElementV2 implements ElementV2 {
  text: String!

  """The ID of an object"""
  id: ID!
  title: String!
  elementType: ElementTypeV2!
  extension: ElementExtension!
}

type TextLearnElement implements LearnElement {
  text: String!

  """The ID of an object"""
  id: ID!
  title: String!
  elementType: ElementTypeV2!
}

type TextPart implements ClozeTextPart {
  text: String!

  """The ID of an object"""
  id: ID!
  kind: ClozeTextPartKind!
}

type TimestampWithImage {
  start: Int!
  end: Int!
  imageFile: File
}

input TimestampWithImageInput {
  start: Int!
  end: Int!
  imageFileId: ID
}

input TransformBusinessAccountToAVGSAccountInput {
  accountId: ID!
  clientMutationId: String
}

type TransformBusinessAccountToAVGSAccountPayload {
  clientMutationId: String
}

input TransformBusinessAccountToAZAVAccountInput {
  accountId: ID!
  clientMutationId: String
}

type TransformBusinessAccountToAZAVAccountPayload {
  clientMutationId: String
}

input TransformPrivateAccountToAVGSAccountInput {
  accountId: ID!
  businessBaseData: BusinessBaseDataInput!
  clientMutationId: String
}

type TransformPrivateAccountToAVGSAccountPayload {
  clientMutationId: String
}

input TransformPrivateAccountToAZAVAccountInput {
  accountId: ID!
  businessBaseData: BusinessBaseDataInput!
  clientMutationId: String
}

type TransformPrivateAccountToAZAVAccountPayload {
  clientMutationId: String
}

type Tree {
  """The ID of an object"""
  id: ID!
  rootNode: TreeNode
  nodes: [TreeNode!]!
}

"""Data only accessible by the admin"""
type TreeAdminMutationSchema {
  setDirectFeedbackFlowELearningContentConfig(input: SetDirectFeedbackFlowELearningContentConfigInput!): SetDirectFeedbackFlowELearningContentConfigPayload
  editDirectFeedbackFlowELearningContentConfig(input: EditDirectFeedbackFlowELearningContentConfigInput!): EditDirectFeedbackFlowELearningContentConfigPayload
  addOnlyEditorsVisibilityTreeConfig(input: AddOnlyEditorsVisibilityTreeConfigInput!): AddOnlyEditorsVisibilityTreeConfigPayload
  setAlwaysRestartContinueContentConfig(input: SetAlwaysRestartContinueContentConfigInput!): SetAlwaysRestartContinueContentConfigPayload
  addOnlyAdminsVisibilityTreeConfig(input: AddOnlyAdminsVisibilityTreeConfigInput!): AddOnlyAdminsVisibilityTreeConfigPayload
  setAlwaysPassContentConfig(input: SetAlwaysPassContentConfigInput!): SetAlwaysPassContentConfigPayload
  setIHKFlowPassContentConfig(input: SetIHKFlowPassContentConfigInput!): SetIHKFlowPassContentConfigPayload
  addExternalLicenseReward(input: AddExternalLicenseRewardInput!): AddExternalLicenseRewardPayload
  editExternalLicenseReward(input: EditExternalLicenseRewardInput!): EditExternalLicenseRewardPayload
  setCanRestartIfPassedContentConfig(input: SetCanRestartIfPassedContentConfigInput!): SetCanRestartIfPassedContentConfigPayload
  addCanNotRestartIfFailedContentConfig(input: AddCanNotRestartIfFailedContentConfigInput!): AddCanNotRestartIfFailedContentConfigPayload
  addCrmTreeHeadUpdaterReward(input: AddCrmTreeHeadUpdaterRewardInput!): AddCrmTreeHeadUpdaterRewardPayload
  addWordPackageReward(input: AddWordPackageRewardInput!): AddWordPackageRewardPayload
  editWordPackageReward(input: EditWordPackageRewardInput!): EditWordPackageRewardPayload
  addDoNotRewardTreeConfig(input: AddDoNotRewardTreeConfigInput!): AddDoNotRewardTreeConfigPayload
  addOnlyBusinessAccountVisibilityTreeConfig(input: AddOnlyBusinessAccountVisibilityTreeConfigInput!): AddOnlyBusinessAccountVisibilityTreeConfigPayload
  addBlockTemporarilyRestartIfFailedContentConfig(input: AddBlockTemporarilyRestartIfFailedContentConfigInput!): AddBlockTemporarilyRestartIfFailedContentConfigPayload
  editBlockTemporarilyRestartIfFailedContentConfig(input: EditBlockTemporarilyRestartIfFailedContentConfigInput!): EditBlockTemporarilyRestartIfFailedContentConfigPayload
  setDoNotShowAnswerTreeConfig(input: SetDoNotShowAnswerTreeConfigInput!): SetDoNotShowAnswerTreeConfigPayload
  addDefaultFileAttachment(input: AddDefaultFileAttachmentInput!): AddDefaultFileAttachmentPayload
  EditDefaultFileAttachment(input: EditDefaultFileAttachmentInput!): EditDefaultFileAttachmentPayload
  setRootExtensionImpl(input: SetRootExtensionImplInput!): SetRootExtensionImplPayload
  addOnlyAZAVAccountVisibilityTreeConfig(input: AddOnlyAZAVAccountVisibilityTreeConfigInput!): AddOnlyAZAVAccountVisibilityTreeConfigPayload
  addEducationalParticipationCertificateReward(input: AddEducationalParticipationCertificateRewardInput!): AddEducationalParticipationCertificateRewardPayload
  editEducationalParticipationCertificateReward(input: EditEducationalParticipationCertificateRewardInput!): EditEducationalParticipationCertificateRewardPayload
  setSimplyContinueFlowELearningContentConfig(input: SetSimplyContinueFlowELearningContentConfigInput!): SetSimplyContinueFlowELearningContentConfigPayload
  AddOnlyIfTreeStateVisibilityTreeConfig(input: AddOnlyIfTreeStateVisibilityTreeConfigInput!): AddOnlyIfTreeStateVisibilityTreeConfigPayload
  addWordProficienciesReward(input: AddWordProficienciesRewardInput!): AddWordProficienciesRewardPayload
  setDoRewardContentConfig(input: SetDoRewardContentConfigInput!): SetDoRewardContentConfigPayload
  addCanIfUnlockedStartContentConfig(input: AddCanIfUnlockedStartContentConfigInput!): AddCanIfUnlockedStartContentConfigPayload
  constellationCreateBranchRoot(input: ConstellationCreateBranchRootInput!): ConstellationCreateBranchRootPayload
  addBlockPermanentlyRestartIfFailedContentConfig(input: AddBlockPermanentlyRestartIfFailedContentConfigInput!): AddBlockPermanentlyRestartIfFailedContentConfigPayload
  editBlockPermanentlyRestartIfFailedContentConfig(input: EditBlockPermanentlyRestartIfFailedContentConfigInput!): EditBlockPermanentlyRestartIfFailedContentConfigPayload
  addHideVisibilityTreeConfig(input: AddHideVisibilityTreeConfigInput!): AddHideVisibilityTreeConfigPayload
  moveChildNode(input: MoveChildNodeInput!): MoveChildNodePayload
  editNodeCore(input: EditNodeCoreInput!): EditNodeCorePayload
  editRootNodePart(input: EditRootNodePartInput!): EditRootNodePartPayload
  removeAttachment(input: RemoveAttachmentInput!): RemoveAttachmentPayload
  deleteReward(input: DeleteRewardInput!): DeleteRewardPayload
  cloneTree(input: CloneTreeInput!): CloneTreePayload
  removeVisibilityTreeConfig(input: RemoveVisibilityTreeConfigInput!): RemoveVisibilityTreeConfigPayload
  removeStartTreeConfig(input: RemoveStartTreeConfigInput!): RemoveStartTreeConfigPayload
  removeRewardTreeConfig(input: RemoveRewardTreeConfigInput!): RemoveRewardTreeConfigPayload
  removeStartContentConfig(input: RemoveStartContentConfigInput!): RemoveStartContentConfigPayload
  removeRestartIfFailedContentConfig(input: RemoveRestartIfFailedContentConfigInput!): RemoveRestartIfFailedContentConfigPayload
  createBranchChild(input: CreateBranchChildInput!): CreateBranchChildPayload
  createBranchRoot(input: CreateBranchRootInput!): CreateBranchRootPayload
  createContentChild(input: CreateContentChildInput!): CreateContentChildPayload
  createContentRoot(input: CreateContentRootNodeInput!): CreateContentRootNodePayload
  removeNodeFromTree(input: RemoveNodeFromTreeInput!): RemoveNodeFromTreePayload
  addAfterDateTimeVisibilityTreeConfig(input: AddAfterDateTimeVisibilityTreeConfigInput!): AddAfterDateTimeVisibilityTreeConfigPayload
  editAfterDateTimeVisibilityTreeConfig(input: EditAfterDateTimeVisibilityTreeConfigInput!): EditAfterDateTimeVisibilityTreeConfigPayload
  addIHKCertificateReward(input: AddIHKCertificateRewardInput!): AddIHKCertificateRewardPayload
  setConstellationRootExtensionExtension(input: SetConstellationRootExtensionExtensionInput!): SetConstellationRootExtensionExtensionPayload
  setContractPartnerInConstellationRootExtensionExtension(input: SetContractPartnerInConstellationRootExtensionExtensionInput!): SetContractPartnerInConstellationRootExtensionExtensionPayload
  setCanNotRestartIfPassedContentConfig(input: SetCanNotRestartIfPassedContentConfigInput!): SetCanNotRestartIfPassedContentConfigPayload
  addCanAfterStartingTreeStartContentConfig(input: AddCanAfterStartingTreeStartContentConfigInput!): AddCanAfterStartingTreeStartContentConfigPayload
  addNotAfterDateTimeVisibilityTreeConfig(input: AddNotAfterDateTimeVisibilityTreeConfigInput!): AddNotAfterDateTimeVisibilityTreeConfigPayload
  editNotAfterDateTimeVisibilityTreeConfig(input: EditNotAfterDateTimeVisibilityTreeConfigInput!): EditNotAfterDateTimeVisibilityTreeConfigPayload
  deleteCourseOrMicroLearningLearnable(input: DeleteCourseOrMicroLearningLearnableInput!): DeleteCourseOrMicroLearningLearnablePayload
}

"""Data only accessible by the admin"""
type TreeAdminSchema {
  Tree(rootId: ID!): Tree!
  GetContentNodes(before: String, after: String, first: Int, last: Int): TreeNodesConnection!
  GetRootNodes(before: String, after: String, first: Int, last: Int, filterByAttachmentId: ID, filterByCanBeRewardedFrom: ZonedDateTIme, filterByCanBeRewardedTo: ZonedDateTIme, filterByIsReleased: Boolean, filterByIsVisibleFrom: ZonedDateTIme, filterByIsVisibleTo: ZonedDateTIme, filterByReleasedAtFrom: ZonedDateTIme, filterByShowAnswersFrom: ZonedDateTIme, filterByShowAnswersTo: ZonedDateTIme, filterByTagIds: [ID!], filterByTitleOrDescriptionOrShortDescription: String): TreeNodesConnection!
}

type TreeLicenseDefinitionData implements LicenseDefinitionData {
  rootInfo: LicenseDefinitionRootInfo
  name: String!
  kind: LicenseDefinitionDataKind!
}

input TreeLicenseDefinitionDataInput {
  name: String!
  rootId: ID!
}

type TreeNode implements Node {
  """The ID of an object"""
  id: ID!
  attachments: [AttachmentV2!]!
  structureDefinition: StructureDefinition!
  typeDefinition: TypeDefinition!
  description: String
  shortDescription: String
  imageId: ID
  image: File
  versioning: Versioning!
  instructors: [Instructor!]!
  parentId: ID
  hasBeenPublishedOnce: Boolean!
  rootId: ID!
}

"""A connection to a list of items."""
type TreeNodesConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [TreeNodesEdge]
}

"""An edge in a connection."""
type TreeNodesEdge {
  """The item at the end of the edge."""
  node: TreeNode!

  """A cursor for use in pagination."""
  cursor: String!
}

type TreeState implements Node {
  """The ID of an object"""
  id: ID!
  user: User
  progressPercentage: Int!
  rootNode: TreeNode!
  startedAt: ZonedDateTIme!
  status: TreeStateStatus!
  extension: TreeStateExtension!
}

interface TreeStateExtension {
  doNotUse: String!
}

"""A connection to a list of items."""
type TreeStatesConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [TreeStatesEdge]
}

"""An edge in a connection."""
type TreeStatesEdge {
  """The item at the end of the edge."""
  node: TreeState!

  """A cursor for use in pagination."""
  cursor: String!
}

enum TreeStateStatus {
  started
  finished
}

type Trend implements Node {
  """The ID of an object"""
  id: ID!
  position: Int
  trendData: TrendData!
  trendMedia: TrendMedia!
  coachingImage: File
  customerData: CustomerData!
  potentialAnalysisHeadingAndDescription: HeadingAndDescription!
  coachingHeadingAndDescription: HeadingAndDescription!
  aboutOffersHeadingAndDescription: HeadingAndDescription!
  learnables: [PublishedLearnable!]!
}

"""Data only accessible by the admin"""
type TrendAdminMutationSchema {
  createTrend(input: CreateTrendInput!): CreateTrendPayload
  editTrend(input: EditTrendInput!): EditTrendPayload
  deleteTrend(input: DeleteTrendInput!): DeleteTrendPayload
  setTrendOrder(input: SetTrendOrderInput!): SetTrendOrderPayload
}

"""Data only accessible by the admin"""
type TrendAdminSchema {
  trend(before: String, after: String, first: Int, last: Int, text: String, isVisible: Boolean): TrendConnection!
}

"""A connection to a list of items."""
type TrendConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [TrendEdge]
}

type TrendData {
  name: String!
  description: String!
  icon: Icon!
  visible: Boolean!
  tags: [AcademiesTag!]!
  advantages: [Advantage!]!
}

input TrendDataInput {
  name: String!
  description: String!
  icon: Icon!
  visible: Boolean!
  tagIds: [ID!]!
  advantages: [AdvantageInput!]!
}

"""An edge in a connection."""
type TrendEdge {
  """The item at the end of the edge."""
  node: Trend!

  """A cursor for use in pagination."""
  cursor: String!
}

input TrendIdWithPosition {
  trendId: ID!
  position: Int!
}

interface TrendMedia {
  file: File
  kind: TrendMediaKind!
}

input TrendMediaInput {
  video: VideoTrendMediaInput
  image: ImageTrendMediaInput
}

enum TrendMediaKind {
  image
  video
}

input TriggerResendActivationInput {
  userId: ID!
  clientMutationId: String
}

type TriggerResendActivationPayload {
  clientMutationId: String
}

input TriggerResetPasswordInput {
  userId: ID!
  clientMutationId: String
}

type TriggerResetPasswordPayload {
  clientMutationId: String
}

interface TypeDefinition {
  definitionType: TypeDefinitionType!
}

enum TypeDefinitionType {
  content
  branch
}

interface UnlockInfo {
  kind: UnlockInfoKind!
}

type UnlockInfoDemo implements UnlockInfo {
  firstContentId: ID!
  firstContentCoordinatesIndexPath: [Int!]!
  kind: UnlockInfoKind!
}

type UnlockInfoFullAccess implements UnlockInfo {
  kind: UnlockInfoKind!
}

enum UnlockInfoKind {
  WallNotFound
  Demo
  FullAccess
  ErrorOccurred
}

type UnlockInfoWallNotFound implements UnlockInfo {
  kind: UnlockInfoKind!
}

type UnpublishedCourseLearnable implements UnpublishedLearnable {
  root: TreeNode
  id: ID!
  kind: LearnableKind!
}

type UnpublishedGroupCoachingLearnable implements UnpublishedLearnable {
  groupCoaching: CoachingOffer
  id: ID!
  kind: LearnableKind!
}

interface UnpublishedLearnable {
  id: ID!
  kind: LearnableKind!
}

"""A connection to a list of items."""
type UnpublishedLearnablesConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [UnpublishedLearnablesEdge]
}

"""An edge in a connection."""
type UnpublishedLearnablesEdge {
  """The item at the end of the edge."""
  node: UnpublishedLearnable!

  """A cursor for use in pagination."""
  cursor: String!
}

type UnpublishedMicroLearningLearnable implements UnpublishedLearnable {
  root: TreeNode
  id: ID!
  kind: LearnableKind!
}

type UnpublishedOneToOneCoachingLearnable implements UnpublishedLearnable {
  oneToOneCoaching: CoachingOffer
  id: ID!
  kind: LearnableKind!
}

type UntouchedAndPreviouslyIncorrectElementState implements ElementState {
  element: LearnElement!
  kind: ElementStateKind!
}

type UntouchedElementState implements ElementState {
  element: LearnElement!
  kind: ElementStateKind!
}

input UpdateBusinessBillingDetailsAndInitiateCheckoutInput {
  company: String!
  companyDetails: String
  invoiceEmail: String
  street: String!
  houseNumber: String!
  postalCode: String!
  city: String!
  country: String!
  phoneNumber: String!
  orderId: ID!
  companyType: CompanyTypeInput!
  clientMutationId: String
}

type UpdateBusinessBillingDetailsAndInitiateCheckoutPayload {
  order: Order!
  clientSecret: String!
  clientMutationId: String
}

input UpdateBusinessBillingDetailsInput {
  company: String!
  companyDetails: String
  invoiceEmail: String
  street: String!
  houseNumber: String!
  postalCode: String!
  city: String!
  country: String!
  phoneNumber: String!
  orderId: ID!
  companyType: CompanyTypeInput!
  clientMutationId: String
}

type UpdateBusinessBillingDetailsPayload {
  order: Order!
  clientMutationId: String
}

input UpdateCartInput {
  cartSelection: CartSelectionInput!
  orderId: ID!
  clientMutationId: String
}

type UpdateCartPayload {
  order: Order!
  clientMutationId: String
}

input UpdateInstructorImplInput {
  data: InstructorImplInput!
  id: ID!
  clientMutationId: String
}

type UpdateInstructorImplPayload {
  data: InstructorImplsEdge!
  clientMutationId: String
}

input UpdatePersonalizedEmailTemplateInput {
  data: PersonalizedEmailTemplateInput!
  id: ID!
  clientMutationId: String
}

type UpdatePersonalizedEmailTemplatePayload {
  data: PersonalizedEmailTemplatesEdge!
  clientMutationId: String
}

input UpdatePersonalizedNotificationTemplateInput {
  data: PersonalizedNotificationTemplateInput!
  id: ID!
  clientMutationId: String
}

type UpdatePersonalizedNotificationTemplatePayload {
  data: PersonalizedNotificationTemplatesEdge!
  clientMutationId: String
}

input UpdatePrivateBillingDetailsAndInitiateCheckoutInput {
  title: String
  firstName: String!
  lastName: String!
  street: String!
  houseNumber: String!
  city: String!
  postalCode: String!
  country: String!
  phoneNumber: String!
  orderId: ID!
  dateOfBirth: ZonedDateTIme!
  salutation: SalutationType!
  clientMutationId: String
}

type UpdatePrivateBillingDetailsAndInitiateCheckoutPayload {
  order: Order!
  clientSecret: String!
  clientMutationId: String
}

input UpdatePrivateBillingDetailsInput {
  title: String
  firstName: String!
  lastName: String!
  street: String!
  houseNumber: String!
  city: String!
  postalCode: String!
  country: String!
  phoneNumber: String!
  orderId: ID!
  dateOfBirth: ZonedDateTIme!
  salutation: SalutationType!
  clientMutationId: String
}

type UpdatePrivateBillingDetailsPayload {
  order: Order!
  clientMutationId: String
}

input UpdateTagInput {
  data: TagInput!
  id: ID!
  clientMutationId: String
}

type UpdateTagPayload {
  data: TagsEdge!
  clientMutationId: String
}

input UpdateUsageLimited {
  onlyForAccountIds: [ID!]!
  maxAmountOfUsages: Int
  onlyForProductIds: [ID!]!
  maxAmountOfUsagesPerAccount: Int
}

type UploadAsyncElement implements AsyncElement {
  """The ID of an object"""
  id: ID!
  title: String!
  taskDescription: String
  assignedEvaluator: User
  kind: AsyncElementKind!
}

interface UploadAsyncElementTask {
  file: File
  id: ID!
  submissionInfo: AsyncElementTaskSubmissionInfo!
  elementKind: AsyncElementKind!
  extension: AsyncElementTaskExtension!
  assignedEvaluator: User
  status: AsyncElementTaskStatus!
}

type UploadAsyncLearnElement implements AsyncLearnElement {
  file: File

  """The ID of an object"""
  id: ID!
  title: String!
  taskDescription: String!
  elementKind: AsyncElementKind!
}

type UploadEvaluation {
  file: File
  text: String
}

type User implements Node {
  """The ID of an object"""
  id: ID!
  activated: Boolean!
  name: String!
  email: String!
  groupAssociations: [UserGroupAssociation!]!
  isDeleted: Boolean!
  registeredAt: ZonedDateTIme!
  extension: UserExtension!
}

"""A connection to a list of items."""
type UserConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [UserEdge]
}

type UserDiscountType implements DiscountType {
  kind: DiscountTypeKind!
}

"""An edge in a connection."""
type UserEdge {
  """The item at the end of the edge."""
  node: User!

  """A cursor for use in pagination."""
  cursor: String!
}

interface UserExtension {
  doNotUse: String!
}

type UserExtensionImpl implements UserExtension {
  avatar: File
  level: Int!
  progressInPercent: Int!
  firstName: String!
  lastName: String!
  adsOptIn: Boolean!
  branch: Branch
  teamSize: TeamSize
  position: String
  sumGamificationPoints: Int!
  firstLogin: Boolean!
  potentialAnalysisMaxRewardAcknowledged: Boolean
  doNotUse: String!
}

type UserGroupAssociation {
  account: Account
  group: UserInAccountGroup
}

type UserInAccount implements Node {
  """The ID of an object"""
  id: ID!
  user: User!
  groups: [UserInAccountGroup!]!
}

"""A connection to a list of items."""
type UserInAccountConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [UserInAccountEdge]
}

"""An edge in a connection."""
type UserInAccountEdge {
  """The item at the end of the edge."""
  node: UserInAccount!

  """A cursor for use in pagination."""
  cursor: String!
}

type UserInAccountGroup implements Node {
  """The ID of an object"""
  id: ID!
  name: String!
  permissions: [Permission!]!
  isBuiltIn: Boolean!
}

"""A connection to a list of items."""
type UserInAccountGroupsConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [UserInAccountGroupsEdge]
}

"""An edge in a connection."""
type UserInAccountGroupsEdge {
  """The item at the end of the edge."""
  node: UserInAccountGroup!

  """A cursor for use in pagination."""
  cursor: String!
}

type UserInAccountGroupWrapper {
  """The ID of an object"""
  id: ID!
  group: UserInAccountGroup!
  newInvitations(before: String, after: String, first: Int, last: Int): AccountMemberConnection!
  memberCount: Long!
}

"""A connection to a list of items."""
type UserInAccountGroupWrapperConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [UserInAccountGroupWrapperEdge]
}

"""An edge in a connection."""
type UserInAccountGroupWrapperEdge {
  """The item at the end of the edge."""
  node: UserInAccountGroupWrapper!

  """A cursor for use in pagination."""
  cursor: String!
}

type UserInAccountGroupWrappersResult {
  userInAccountGroupWrappers(before: String, after: String, first: Int, last: Int): UserInAccountGroupWrapperConnection!
  count: Long!
}

type UserInAccountWrapper implements AccountMember {
  user: UserInAccount!
  id: ID!
  name: String!
  groups: [UserInAccountGroup!]!
  isManager: Boolean!
  kind: AccountMemberKind!
}

type Versioning {
  draftVersion: Int!
  releaseVersion: Int!
}

type VideoDataV2 {
  videoId: String!
  name: String!
  duration: Int!
  thumbnailUrl: String!
}

type VideoElement implements ElementV2 {
  vimeoId: String!

  """The ID of an object"""
  id: ID!
  title: String!
  elementType: ElementTypeV2!
  extension: ElementExtension!
}

type VideoLearnElement implements LearnElement {
  videoFile: File
  streamFile: StreamFile
  thumbnailFile: File
  durationInSec: Int!
  subtitles: [SubtitlesForLanguage!]!

  """The ID of an object"""
  id: ID!
  title: String!
  elementType: ElementTypeV2!
}

type VideoSubtitle {
  startTimeInSec: Long!
  endTimeInSec: Long!
  text: String!
}

type VideoTrendMedia implements TrendMedia {
  file: File
  kind: TrendMediaKind!
}

input VideoTrendMediaInput {
  fileId: ID!
  trendMediaType: TrendMediaKind!
}

"""Data partaining to the current user"""
type ViewerMutationType {
  Auth: AuthViewerMutationSchema!
}

"""Data partaining to the current user"""
type ViewerQueryType {
  Learn: LearnViewerSchema!
  Auth: AuthViewerSchema!
  PotentialAnalysis: PotentialAnalysisViewerSchema!
  Coaching: CoachingViewerSchema!
  Reports: ReportsViewerSchema!
  Billing: BillingViewerSchema!
}

interface ViewerTreeState {
  kind: ViewerTreeStateKind!
}

enum ViewerTreeStateKind {
  CanBeStarted
  CanNotBeStarted
  IsFinished
  IsStarted
  NotVisible
}

type VimeoPodcastSourceV2 implements PodcastSourceV2 {
  vimeoId: String!
  sourceType: PodcastSourceTypeV2!
}

interface VisibilityCoachingConfig {
  """The ID of an object"""
  id: ID!
  configType: VisibilityCoachingConfigType!
}

enum VisibilityCoachingConfigType {
  VisibilityCoaching_Hide
  VisibilityCoaching_OnlyAZAVAccount
  VisibilityCoaching_OnlyWithLicense
  VisibilityCoaching_OnlyBusinessAccount
}

interface VisibilityTreeConfig {
  """The ID of an object"""
  id: ID!
  configType: VisibilityTreeConfigType!
}

enum VisibilityTreeConfigType {
  VisibilityTree_OnlyEditors
  VisibilityTree_OnlyAdmins
  VisibilityTree_OnlyBusinessAccount
  VisibilityTree_OnlyAZAVAccount
  VisibilityTree_OnlyIfTreeState
  VisibilityTree_OnlyPermissionsImpl
  VisibilityTree_Hide
  VisibilityTree_AfterDateTime
  VisibilityTree_NotAfterDateTime
}

"""Data only accessible by the admin"""
type VocabAdminMutationSchema {
  createWordPackage(input: CreateWordPackageInput!): CreateWordPackagePayload
  editWordPackage(input: EditWordPackageInput!): EditWordPackagePayload
  addWordToPackage(input: AddWordToPackageInput!): AddWordToPackagePayload
  editWord(input: EditWordInput!): EditWordPayload
  deleteWord(input: DeleteWordInput!): DeleteWordPayload
  deleteWordPackage(input: DeleteWordPackageInput!): DeleteWordPackagePayload
}

"""Data only accessible by the admin"""
type VocabAdminSchema {
  WordPackages(before: String, after: String, first: Int, last: Int, filterByName: String, alwaysInclude: [ID!]): WordPackageConnection!
}

type VocabMutations {
  addWordNote(input: AddWordNoteInput!): AddWordNotePayload
  startStandaloneVocabTraining(input: StartStandaloneVocabTrainingInput!): StartStandaloneVocabTrainingPayload
}

type VocabQueries {
  MyWordInventory: WordInventory
}

interface VocabTrainWordPackageSelection {
  wordPackage: WordPackage
  kind: VocabTrainWordPackageSelectionKind!
}

type VocabTrainWordPackageSelectionFullPackage implements VocabTrainWordPackageSelection {
  wordPackage: WordPackage
  kind: VocabTrainWordPackageSelectionKind!
}

enum VocabTrainWordPackageSelectionKind {
  FullPackage
  SpecificWords
}

type VocabTrainWordPackageSelectionSpecificWords implements VocabTrainWordPackageSelection {
  wordIds: [ID!]!
  wordPackage: WordPackage
  kind: VocabTrainWordPackageSelectionKind!
}

type Word {
  """The ID of an object"""
  id: ID!
  word: String!
  translation: String
  explanation: String!
}

input WordInPackageInput {
  packageId: ID!
  wordId: ID!
}

type WordInventory {
  """The ID of an object"""
  id: ID!
  packages: [PackageUnlock!]!
  proficiencies: [WordProficiency!]!
  notes: [WordNote!]!
}

type WordNote {
  wordId: ID!
  note: String!
}

type WordPackage implements Node {
  """The ID of an object"""
  id: ID!
  name: String!
  language: String!
  associatedWords: [Word!]!
}

type WordPackage_ErrorOccurredRewardResult implements RewardResult {
  rewardId: ID!
  rewardKind: RewardKind!
  kind: RewardResultKind!
}

type WordPackage_NothingNewToUnlockRewardResult implements RewardResult {
  wordPackage: WordPackage
  rewardId: ID!
  rewardKind: RewardKind!
  kind: RewardResultKind!
}

type WordPackage_PackageUnlockedRewardResult implements RewardResult {
  wordPackage: WordPackage
  rewardId: ID!
  rewardKind: RewardKind!
  kind: RewardResultKind!
}

"""A connection to a list of items."""
type WordPackageConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [WordPackageEdge]
}

input WordPackageDataInput {
  name: String!
  language: String!
}

"""An edge in a connection."""
type WordPackageEdge {
  """The item at the end of the edge."""
  node: WordPackage!

  """A cursor for use in pagination."""
  cursor: String!
}

type WordPackageReward implements Reward {
  data: WordPackageRewardData!

  """The ID of an object"""
  id: ID!
  superId: ID!
  kind: RewardKind!
}

type WordPackageRewardData {
  wordPackage: WordPackage
}

input WordPackageRewardDataInput {
  wordPackageId: ID!
}

type WordProficiencies_ErrorOccurredRewardResult implements RewardResult {
  rewardId: ID!
  rewardKind: RewardKind!
  kind: RewardResultKind!
}

type WordProficiencies_ProficienciesChangedRewardResult implements RewardResult {
  rewardId: ID!
  rewardKind: RewardKind!
  kind: RewardResultKind!
}

type WordProficienciesReward implements Reward {
  """The ID of an object"""
  id: ID!
  superId: ID!
  kind: RewardKind!
}

type WordProficiency {
  wordId: ID!
  proficiencyLevel: Int!
}

scalar ZonedDateTIme

